'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var PropTypes = _interopDefault(require('prop-types'));
var Liowebrtc = _interopDefault(require('liowebrtc'));

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Context = React.createContext();

function withWebRTC(Component) {

  return function ContextComponent(props) {
    return React.createElement(
      Context.Consumer,
      null,
      function (webrtc) {
        return React.createElement(Component, _extends({}, props, { webrtc: webrtc }));
      }
    );
  };
}

var LioWebRTC = function (_React$Component) {
  inherits(LioWebRTC, _React$Component);

  function LioWebRTC(props) {
    classCallCheck(this, LioWebRTC);

    var _this = possibleConstructorReturn(this, (LioWebRTC.__proto__ || Object.getPrototypeOf(LioWebRTC)).call(this, props));

    _this.disconnect = function () {
      try {
        _this.webrtc.stopLocalVideo();
        _this.webrtc.leaveRoom();
        _this.webrtc.disconnect();
      } catch (e) {
        // console.log(e);
      }
    };

    _this.webrtc = new Liowebrtc(props.options);
    return _this;
  }

  createClass(LioWebRTC, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _props = this.props,
          onReady = _props.onReady,
          onReceivedPeerData = _props.onReceivedPeerData,
          onChannelOpen = _props.onChannelOpen,
          onConnectionReady = _props.onConnectionReady,
          onCreatedPeer = _props.onCreatedPeer,
          onPeerStreamAdded = _props.onPeerStreamAdded,
          onPeerStreamRemoved = _props.onPeerStreamRemoved,
          onRemovedPeer = _props.onRemovedPeer,
          onIceConnectionStateChange = _props.onIceConnectionStateChange,
          onSignalingStateChange = _props.onSignalingStateChange,
          onLeftRoom = _props.onLeftRoom,
          onJoinedRoom = _props.onJoinedRoom,
          onPeerMute = _props.onPeerMute,
          onReceivedSignalData = _props.onReceivedSignalData,
          onPeerUnmute = _props.onPeerUnmute,
          onConnectionError = _props.onConnectionError;


      onReceivedPeerData && this.webrtc.on('receivedPeerData', function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        onReceivedPeerData.apply(undefined, [this].concat(args));
      });
      onReady && this.webrtc.on('ready', function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        onReady.apply(undefined, [this].concat(args));
      });
      onChannelOpen && this.webrtc.on('channelOpen', function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        onChannelOpen.apply(undefined, [this].concat(args));
      });
      onConnectionReady && this.webrtc.on('connectionReady', function () {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        onConnectionReady.apply(undefined, [this].concat(args));
      });
      onCreatedPeer && this.webrtc.on('createdPeer', function () {
        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        onCreatedPeer.apply(undefined, [this].concat(args));
      });
      onPeerStreamRemoved && this.webrtc.on('peerStreamRemoved', function () {
        for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        onPeerStreamRemoved.apply(undefined, [this].concat(args));
      });
      onIceConnectionStateChange && this.webrtc.on('iceConnectionStateChange', function () {
        for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        onIceConnectionStateChange.apply(undefined, [this].concat(args));
      });
      onSignalingStateChange && this.webrtc.on('signalingStateChange', function () {
        for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          args[_key8] = arguments[_key8];
        }

        onSignalingStateChange.apply(undefined, [this].concat(args));
      });
      onLeftRoom && this.webrtc.on('leftRoom', function () {
        for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          args[_key9] = arguments[_key9];
        }

        onLeftRoom.apply(undefined, [this].concat(args));
      });
      onJoinedRoom && this.webrtc.on('joinedRoom', function () {
        for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          args[_key10] = arguments[_key10];
        }

        onJoinedRoom.apply(undefined, [this].concat(args));
      });
      onPeerMute && this.webrtc.on('mute', function () {
        for (var _len11 = arguments.length, args = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
          args[_key11] = arguments[_key11];
        }

        onPeerMute.apply(undefined, [this].concat(args));
      });
      onPeerUnmute && this.webrtc.on('unmute', function () {
        for (var _len12 = arguments.length, args = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
          args[_key12] = arguments[_key12];
        }

        onPeerUnmute.apply(undefined, [this].concat(args));
      });
      onReceivedSignalData && this.webrtc.on('receivedSignalData', function () {
        for (var _len13 = arguments.length, args = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
          args[_key13] = arguments[_key13];
        }

        onReceivedSignalData.apply(undefined, [this].concat(args));
      });
      onPeerStreamAdded && this.webrtc.on('peerStreamAdded', function () {
        for (var _len14 = arguments.length, args = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
          args[_key14] = arguments[_key14];
        }

        onPeerStreamAdded.apply(undefined, [this].concat(args));
      });
      onRemovedPeer && this.webrtc.on('removedPeer', function () {
        for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
          args[_key15] = arguments[_key15];
        }

        onRemovedPeer.apply(undefined, [this].concat(args));
      });
      onConnectionError && this.webrtc.on('connectivityError', function () {
        for (var _len16 = arguments.length, args = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
          args[_key16] = arguments[_key16];
        }

        onConnectionError.apply(undefined, [this].concat(args));
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.disconnect();
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        null,
        React.createElement(
          Context.Provider,
          { value: this.webrtc },
          this.props.children
        )
      );
    }
  }]);
  return LioWebRTC;
}(React.Component);

LioWebRTC.propTypes = {
  options: PropTypes.object,
  onReady: PropTypes.func,
  onJoinedRoom: PropTypes.func,
  onChannelOpen: PropTypes.func,
  onReceivedPeerData: PropTypes.func,
  onConnectionReady: PropTypes.func,
  onCreatedPeer: PropTypes.func,
  onPeerStreamRemoved: PropTypes.func,
  onIceConnectionStateChange: PropTypes.func,
  onSignalingStateChange: PropTypes.func,
  onLeftRoom: PropTypes.func,
  onPeerMute: PropTypes.func,
  onReceivedSignalData: PropTypes.func,
  onPeerUnmute: PropTypes.func,
  onPeerStreamAdded: PropTypes.func,
  onRemovedPeer: PropTypes.func,
  onConnectionError: PropTypes.func
};

LioWebRTC.defaultProps = {
  options: {
    dataOnly: true,
    debug: false
  }
};

var LocalVideo = function (_React$Component) {
  inherits(LocalVideo, _React$Component);

  function LocalVideo() {
    classCallCheck(this, LocalVideo);
    return possibleConstructorReturn(this, (LocalVideo.__proto__ || Object.getPrototypeOf(LocalVideo)).apply(this, arguments));
  }

  createClass(LocalVideo, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.props.webrtc.setLocalVideo(this.localVid);
      this.props.webrtc.startLocalVideo();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return React.createElement('video', _extends({}, this.props.videoProps, {
        id: 'localVideo',
        ref: function ref(vid) {
          _this2.localVid = vid;
        }
      }));
    }
  }]);
  return LocalVideo;
}(React.Component);

LocalVideo.propTypes = {
  videoProps: PropTypes.object
};

var index = withWebRTC(LocalVideo);

var RemoteVideo = function (_React$Component) {
  inherits(RemoteVideo, _React$Component);

  function RemoteVideo() {
    classCallCheck(this, RemoteVideo);
    return possibleConstructorReturn(this, (RemoteVideo.__proto__ || Object.getPrototypeOf(RemoteVideo)).apply(this, arguments));
  }

  createClass(RemoteVideo, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.props.webrtc.on('peerStreamAdded', function (stream, peer) {
        if (peer.id === _this2.props.peer.id) {
          _this2.props.webrtc.attachStream(stream, _this2.remoteVid);
        }
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      return React.createElement('video', _extends({}, this.props.videoProps, {
        id: this.props.webrtc.getDomId(this.props.peer),
        ref: function ref(vid) {
          _this3.remoteVid = vid;
        }
      }));
    }
  }]);
  return RemoteVideo;
}(React.Component);

RemoteVideo.propTypes = {
  videoProps: PropTypes.object,
  peer: PropTypes.any.isRequired
};

var index$1 = withWebRTC(RemoteVideo);

exports.LioWebRTC = LioWebRTC;
exports.withWebRTC = withWebRTC;
exports.LocalVideo = index;
exports.RemoteVideo = index$1;
//# sourceMappingURL=index.js.map

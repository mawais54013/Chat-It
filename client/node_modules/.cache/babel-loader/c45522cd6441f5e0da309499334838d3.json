{"ast":null,"code":"var util = require('util');\n\nvar SJJ = require('sdp-jingle-json');\n\nvar WildEmitter = require('wildemitter');\n\nvar cloneDeep = require('lodash.clonedeep');\n\nfunction PeerConnection(config, constraints) {\n  var self = this;\n  var item;\n  WildEmitter.call(this);\n  config = config || {};\n  config.iceServers = config.iceServers || []; // make sure this only gets enabled in Google Chrome\n  // EXPERIMENTAL FLAG, might get removed without notice\n\n  this.enableChromeNativeSimulcast = false;\n\n  if (constraints && constraints.optional && window.chrome && navigator.appVersion.match(/Chromium\\//) === null) {\n    constraints.optional.forEach(function (constraint) {\n      if (constraint.enableChromeNativeSimulcast) {\n        self.enableChromeNativeSimulcast = true;\n      }\n    });\n  } // EXPERIMENTAL FLAG, might get removed without notice\n\n\n  this.enableMultiStreamHacks = false;\n\n  if (constraints && constraints.optional && window.chrome) {\n    constraints.optional.forEach(function (constraint) {\n      if (constraint.enableMultiStreamHacks) {\n        self.enableMultiStreamHacks = true;\n      }\n    });\n  } // EXPERIMENTAL FLAG, might get removed without notice\n\n\n  this.restrictBandwidth = 0;\n\n  if (constraints && constraints.optional) {\n    constraints.optional.forEach(function (constraint) {\n      if (constraint.andyetRestrictBandwidth) {\n        self.restrictBandwidth = constraint.andyetRestrictBandwidth;\n      }\n    });\n  } // EXPERIMENTAL FLAG, might get removed without notice\n  // bundle up ice candidates, only works for jingle mode\n  // number > 0 is the delay to wait for additional candidates\n  // ~20ms seems good\n\n\n  this.batchIceCandidates = 0;\n\n  if (constraints && constraints.optional) {\n    constraints.optional.forEach(function (constraint) {\n      if (constraint.andyetBatchIce) {\n        self.batchIceCandidates = constraint.andyetBatchIce;\n      }\n    });\n  }\n\n  this.batchedIceCandidates = []; // EXPERIMENTAL FLAG, might get removed without notice\n  // this attemps to strip out candidates with an already known foundation\n  // and type -- i.e. those which are gathered via the same TURN server\n  // but different transports (TURN udp, tcp and tls respectively)\n\n  if (constraints && constraints.optional && window.chrome) {\n    constraints.optional.forEach(function (constraint) {\n      if (constraint.andyetFasterICE) {\n        self.eliminateDuplicateCandidates = constraint.andyetFasterICE;\n      }\n    });\n  } // EXPERIMENTAL FLAG, might get removed without notice\n  // when using a server such as the jitsi videobridge we don't need to signal\n  // our candidates\n\n\n  if (constraints && constraints.optional) {\n    constraints.optional.forEach(function (constraint) {\n      if (constraint.andyetDontSignalCandidates) {\n        self.dontSignalCandidates = constraint.andyetDontSignalCandidates;\n      }\n    });\n  } // EXPERIMENTAL FLAG, might get removed without notice\n\n\n  this.assumeSetLocalSuccess = false;\n\n  if (constraints && constraints.optional) {\n    constraints.optional.forEach(function (constraint) {\n      if (constraint.andyetAssumeSetLocalSuccess) {\n        self.assumeSetLocalSuccess = constraint.andyetAssumeSetLocalSuccess;\n      }\n    });\n  } // EXPERIMENTAL FLAG, might get removed without notice\n  // working around https://bugzilla.mozilla.org/show_bug.cgi?id=1087551\n  // pass in a timeout for this\n\n\n  if (window.navigator.mozGetUserMedia) {\n    if (constraints && constraints.optional) {\n      this.wtFirefox = 0;\n      constraints.optional.forEach(function (constraint) {\n        if (constraint.andyetFirefoxMakesMeSad) {\n          self.wtFirefox = constraint.andyetFirefoxMakesMeSad;\n\n          if (self.wtFirefox > 0) {\n            self.firefoxcandidatebuffer = [];\n          }\n        }\n      });\n    }\n  }\n\n  this.pc = new RTCPeerConnection(config, constraints);\n\n  if (typeof this.pc.getLocalStreams === 'function') {\n    this.getLocalStreams = this.pc.getLocalStreams.bind(this.pc);\n  } else {\n    this.getLocalStreams = function () {\n      return [];\n    };\n  }\n\n  if (typeof this.pc.getSenders === 'function') {\n    this.getSenders = this.pc.getSenders.bind(this.pc);\n  } else {\n    this.getSenders = function () {\n      return [];\n    };\n  }\n\n  if (typeof this.pc.getRemoteStreams === 'function') {\n    this.getRemoteStreams = this.pc.getRemoteStreams.bind(this.pc);\n  } else {\n    this.getRemoteStreams = function () {\n      return [];\n    };\n  }\n\n  if (typeof this.pc.getReceivers === 'function') {\n    this.getReceivers = this.pc.getReceivers.bind(this.pc);\n  } else {\n    this.getReceivers = function () {\n      return [];\n    };\n  }\n\n  this.addStream = this.pc.addStream.bind(this.pc);\n\n  this.removeStream = function (stream) {\n    if (typeof self.pc.removeStream === 'function') {\n      self.pc.removeStream.apply(self.pc, arguments);\n    } else if (typeof self.pc.removeTrack === 'function') {\n      stream.getTracks().forEach(function (track) {\n        self.pc.removeTrack(track);\n      });\n    }\n  };\n\n  if (typeof this.pc.removeTrack === 'function') {\n    this.removeTrack = this.pc.removeTrack.bind(this.pc);\n  } // proxy some events directly\n\n\n  this.pc.onremovestream = this.emit.bind(this, 'removeStream');\n  this.pc.onremovetrack = this.emit.bind(this, 'removeTrack');\n  this.pc.onaddstream = this.emit.bind(this, 'addStream');\n  this.pc.ontrack = this.emit.bind(this, 'addTrack');\n  this.pc.onnegotiationneeded = this.emit.bind(this, 'negotiationNeeded');\n  this.pc.oniceconnectionstatechange = this.emit.bind(this, 'iceConnectionStateChange');\n  this.pc.onsignalingstatechange = this.emit.bind(this, 'signalingStateChange'); // handle ice candidate and data channel events\n\n  this.pc.onicecandidate = this._onIce.bind(this);\n  this.pc.ondatachannel = this._onDataChannel.bind(this);\n  this.localDescription = {\n    contents: []\n  };\n  this.remoteDescription = {\n    contents: []\n  };\n  this.config = {\n    debug: false,\n    sid: '',\n    isInitiator: true,\n    sdpSessionID: Date.now(),\n    useJingle: false\n  };\n  this.iceCredentials = {\n    local: {},\n    remote: {}\n  }; // apply our config\n\n  for (item in config) {\n    this.config[item] = config[item];\n  }\n\n  if (this.config.debug) {\n    this.on('*', function () {\n      var logger = config.logger || console;\n      logger.log('PeerConnection event:', arguments);\n    });\n  }\n\n  this.hadLocalStunCandidate = false;\n  this.hadRemoteStunCandidate = false;\n  this.hadLocalRelayCandidate = false;\n  this.hadRemoteRelayCandidate = false;\n  this.hadLocalIPv6Candidate = false;\n  this.hadRemoteIPv6Candidate = false; // keeping references for all our data channels\n  // so they dont get garbage collected\n  // can be removed once the following bugs have been fixed\n  // https://crbug.com/405545\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=964092\n  // to be filed for opera\n\n  this._remoteDataChannels = [];\n  this._localDataChannels = [];\n  this._candidateBuffer = [];\n}\n\nutil.inherits(PeerConnection, WildEmitter);\nObject.defineProperty(PeerConnection.prototype, 'signalingState', {\n  get: function get() {\n    return this.pc.signalingState;\n  }\n});\nObject.defineProperty(PeerConnection.prototype, 'iceConnectionState', {\n  get: function get() {\n    return this.pc.iceConnectionState;\n  }\n});\n\nPeerConnection.prototype._role = function () {\n  return this.isInitiator ? 'initiator' : 'responder';\n}; // Add a stream to the peer connection object\n\n\nPeerConnection.prototype.addStream = function (stream) {\n  this.localStream = stream;\n  stream.getTracks().forEach(function (track) {\n    this.pc.addTrack(track, stream);\n  });\n}; // helper function to check if a remote candidate is a stun/relay\n// candidate or an ipv6 candidate\n\n\nPeerConnection.prototype._checkLocalCandidate = function (candidate) {\n  var cand = SJJ.toCandidateJSON(candidate);\n\n  if (cand.type == 'srflx') {\n    this.hadLocalStunCandidate = true;\n  } else if (cand.type == 'relay') {\n    this.hadLocalRelayCandidate = true;\n  }\n\n  if (cand.ip.indexOf(':') != -1) {\n    this.hadLocalIPv6Candidate = true;\n  }\n}; // helper function to check if a remote candidate is a stun/relay\n// candidate or an ipv6 candidate\n\n\nPeerConnection.prototype._checkRemoteCandidate = function (candidate) {\n  var cand = SJJ.toCandidateJSON(candidate);\n\n  if (cand.type == 'srflx') {\n    this.hadRemoteStunCandidate = true;\n  } else if (cand.type == 'relay') {\n    this.hadRemoteRelayCandidate = true;\n  }\n\n  if (cand.ip.indexOf(':') != -1) {\n    this.hadRemoteIPv6Candidate = true;\n  }\n}; // Init and add ice candidate object with correct constructor\n\n\nPeerConnection.prototype.processIce = function (update, cb) {\n  cb = cb || function () {};\n\n  var self = this; // ignore any added ice candidates to avoid errors. why does the\n  // spec not do this?\n\n  if (this.pc.signalingState === 'closed') return cb();\n\n  if (update.contents || update.jingle && update.jingle.contents) {\n    var contentNames = this.remoteDescription.contents.map(function (c) {\n      return c.name;\n    });\n    var contents = update.contents || update.jingle.contents;\n    contents.forEach(function (content) {\n      var transport = content.transport || {};\n      var candidates = transport.candidates || [];\n      var mline = contentNames.indexOf(content.name);\n      var mid = content.name;\n      var remoteContent = self.remoteDescription.contents.find(function (c) {\n        return c.name === content.name;\n      }); // process candidates as a callback, in case we need to\n      // update ufrag and pwd with offer/answer\n\n      var processCandidates = function processCandidates() {\n        candidates.forEach(function (candidate) {\n          var iceCandidate = SJJ.toCandidateSDP(candidate);\n          self.pc.addIceCandidate(new RTCIceCandidate({\n            candidate: iceCandidate,\n            sdpMLineIndex: mline,\n            sdpMid: mid\n          })).then(function () {// well, this success callback is pretty meaningless\n          }, function (err) {\n            self.emit('error', err);\n          });\n\n          self._checkRemoteCandidate(iceCandidate);\n        });\n        cb();\n      };\n\n      if (self.iceCredentials.remote[content.name] && transport.ufrag && self.iceCredentials.remote[content.name].ufrag !== transport.ufrag) {\n        if (remoteContent) {\n          remoteContent.transport.ufrag = transport.ufrag;\n          remoteContent.transport.pwd = transport.pwd;\n          var offer = {\n            type: 'offer',\n            jingle: self.remoteDescription\n          };\n          offer.sdp = SJJ.toSessionSDP(offer.jingle, {\n            sid: self.config.sdpSessionID,\n            role: self._role(),\n            direction: 'incoming'\n          });\n          self.pc.setRemoteDescription(new RTCSessionDescription(offer)).then(function () {\n            processCandidates();\n          }, function (err) {\n            self.emit('error', err);\n          });\n        } else {\n          self.emit('error', 'ice restart failed to find matching content');\n        }\n      } else {\n        processCandidates();\n      }\n    });\n  } else {\n    // working around https://code.google.com/p/webrtc/issues/detail?id=3669\n    if (update.candidate && update.candidate.candidate.indexOf('a=') !== 0) {\n      update.candidate.candidate = 'a=' + update.candidate.candidate;\n    }\n\n    if (this.wtFirefox && this.firefoxcandidatebuffer !== null) {\n      // we cant add this yet due to https://bugzilla.mozilla.org/show_bug.cgi?id=1087551\n      if (this.pc.localDescription && this.pc.localDescription.type === 'offer') {\n        this.firefoxcandidatebuffer.push(update.candidate);\n        return cb();\n      }\n    }\n\n    self.pc.addIceCandidate(new RTCIceCandidate(update.candidate)).then(function () {}, function (err) {\n      self.emit('error', err);\n    });\n\n    self._checkRemoteCandidate(update.candidate.candidate);\n\n    cb();\n  }\n}; // Generate and emit an offer with the given constraints\n\n\nPeerConnection.prototype.offer = function (constraints, cb) {\n  var self = this;\n  var hasConstraints = arguments.length === 2;\n  var mediaConstraints = hasConstraints && constraints ? constraints : {\n    offerToReceiveAudio: 1,\n    offerToReceiveVideo: 1\n  };\n  cb = hasConstraints ? cb : constraints;\n\n  cb = cb || function () {};\n\n  if (this.pc.signalingState === 'closed') return cb('Already closed'); // Actually generate the offer\n\n  this.pc.createOffer(mediaConstraints).then(function (offer) {\n    // does not work for jingle, but jingle.js doesn't need\n    // this hack...\n    var expandedOffer = {\n      type: 'offer',\n      sdp: offer.sdp\n    };\n\n    if (self.assumeSetLocalSuccess) {\n      self.emit('offer', expandedOffer);\n      cb(null, expandedOffer);\n    }\n\n    self._candidateBuffer = [];\n    self.pc.setLocalDescription(offer).then(function () {\n      var jingle;\n\n      if (self.config.useJingle) {\n        jingle = SJJ.toSessionJSON(offer.sdp, {\n          role: self._role(),\n          direction: 'outgoing'\n        });\n        jingle.sid = self.config.sid;\n        self.localDescription = jingle; // Save ICE credentials\n\n        jingle.contents.forEach(function (content) {\n          var transport = content.transport || {};\n\n          if (transport.ufrag) {\n            self.iceCredentials.local[content.name] = {\n              ufrag: transport.ufrag,\n              pwd: transport.pwd\n            };\n          }\n        });\n        expandedOffer.jingle = jingle;\n      }\n\n      expandedOffer.sdp.split(/\\r?\\n/).forEach(function (line) {\n        if (line.indexOf('a=candidate:') === 0) {\n          self._checkLocalCandidate(line);\n        }\n      });\n\n      if (!self.assumeSetLocalSuccess) {\n        self.emit('offer', expandedOffer);\n        cb(null, expandedOffer);\n      }\n    }, function (err) {\n      self.emit('error', err);\n      cb(err);\n    });\n  }, function (err) {\n    self.emit('error', err);\n    cb(err);\n  });\n}; // Process an incoming offer so that ICE may proceed before deciding\n// to answer the request.\n\n\nPeerConnection.prototype.handleOffer = function (offer, cb) {\n  cb = cb || function () {};\n\n  var self = this;\n  offer.type = 'offer';\n\n  if (offer.jingle) {\n    if (this.enableChromeNativeSimulcast) {\n      offer.jingle.contents.forEach(function (content) {\n        if (content.name === 'video') {\n          content.application.googConferenceFlag = true;\n        }\n      });\n    }\n\n    if (this.enableMultiStreamHacks) {\n      // add a mixed video stream as first stream\n      offer.jingle.contents.forEach(function (content) {\n        if (content.name === 'video') {\n          var sources = content.application.sources || [];\n\n          if (sources.length === 0 || sources[0].ssrc !== \"3735928559\") {\n            sources.unshift({\n              ssrc: \"3735928559\",\n              // 0xdeadbeef\n              parameters: [{\n                key: \"cname\",\n                value: \"deadbeef\"\n              }, {\n                key: \"msid\",\n                value: \"mixyourfecintothis please\"\n              }]\n            });\n            content.application.sources = sources;\n          }\n        }\n      });\n    }\n\n    if (self.restrictBandwidth > 0) {\n      if (offer.jingle.contents.length >= 2 && offer.jingle.contents[1].name === 'video') {\n        var content = offer.jingle.contents[1];\n        var hasBw = content.application && content.application.bandwidth && content.application.bandwidth.bandwidth;\n\n        if (!hasBw) {\n          offer.jingle.contents[1].application.bandwidth = {\n            type: 'AS',\n            bandwidth: self.restrictBandwidth.toString()\n          };\n          offer.sdp = SJJ.toSessionSDP(offer.jingle, {\n            sid: self.config.sdpSessionID,\n            role: self._role(),\n            direction: 'outgoing'\n          });\n        }\n      }\n    } // Save ICE credentials\n\n\n    offer.jingle.contents.forEach(function (content) {\n      var transport = content.transport || {};\n\n      if (transport.ufrag) {\n        self.iceCredentials.remote[content.name] = {\n          ufrag: transport.ufrag,\n          pwd: transport.pwd\n        };\n      }\n    });\n    offer.sdp = SJJ.toSessionSDP(offer.jingle, {\n      sid: self.config.sdpSessionID,\n      role: self._role(),\n      direction: 'incoming'\n    });\n    self.remoteDescription = offer.jingle;\n  }\n\n  offer.sdp.split(/\\r?\\n/).forEach(function (line) {\n    if (line.indexOf('a=candidate:') === 0) {\n      self._checkRemoteCandidate(line);\n    }\n  });\n  self.pc.setRemoteDescription(new RTCSessionDescription(offer)).then(function () {\n    cb();\n  }, cb);\n}; // Answer an offer with audio only\n\n\nPeerConnection.prototype.answerAudioOnly = function (cb) {\n  var mediaConstraints = {\n    mandatory: {\n      OfferToReceiveAudio: true,\n      OfferToReceiveVideo: false\n    }\n  };\n\n  this._answer(mediaConstraints, cb);\n}; // Answer an offer without offering to recieve\n\n\nPeerConnection.prototype.answerBroadcastOnly = function (cb) {\n  var mediaConstraints = {\n    mandatory: {\n      OfferToReceiveAudio: false,\n      OfferToReceiveVideo: false\n    }\n  };\n\n  this._answer(mediaConstraints, cb);\n}; // Answer an offer with given constraints default is audio/video\n\n\nPeerConnection.prototype.answer = function (constraints, cb) {\n  var hasConstraints = arguments.length === 2;\n  var callback = hasConstraints ? cb : constraints;\n  var mediaConstraints = hasConstraints && constraints ? constraints : {\n    mandatory: {\n      OfferToReceiveAudio: true,\n      OfferToReceiveVideo: true\n    }\n  };\n\n  this._answer(mediaConstraints, callback);\n}; // Process an answer\n\n\nPeerConnection.prototype.handleAnswer = function (answer, cb) {\n  cb = cb || function () {};\n\n  var self = this;\n\n  if (answer.jingle) {\n    answer.sdp = SJJ.toSessionSDP(answer.jingle, {\n      sid: self.config.sdpSessionID,\n      role: self._role(),\n      direction: 'incoming'\n    });\n    self.remoteDescription = answer.jingle; // Save ICE credentials\n\n    answer.jingle.contents.forEach(function (content) {\n      var transport = content.transport || {};\n\n      if (transport.ufrag) {\n        self.iceCredentials.remote[content.name] = {\n          ufrag: transport.ufrag,\n          pwd: transport.pwd\n        };\n      }\n    });\n  }\n\n  answer.sdp.split(/\\r?\\n/).forEach(function (line) {\n    if (line.indexOf('a=candidate:') === 0) {\n      self._checkRemoteCandidate(line);\n    }\n  });\n  self.pc.setRemoteDescription(new RTCSessionDescription(answer)).then(function () {\n    if (self.wtFirefox) {\n      window.setTimeout(function () {\n        self.firefoxcandidatebuffer.forEach(function (candidate) {\n          // add candidates later\n          self.pc.addIceCandidate(new RTCIceCandidate(candidate)).then(function () {}, function (err) {\n            self.emit('error', err);\n          });\n\n          self._checkRemoteCandidate(candidate.candidate);\n        });\n        self.firefoxcandidatebuffer = null;\n      }, self.wtFirefox);\n    }\n\n    cb(null);\n  }, cb);\n}; // Close the peer connection\n\n\nPeerConnection.prototype.close = function () {\n  this.pc.close();\n  this._localDataChannels = [];\n  this._remoteDataChannels = [];\n  this.emit('close');\n}; // Internal code sharing for various types of answer methods\n\n\nPeerConnection.prototype._answer = function (constraints, cb) {\n  cb = cb || function () {};\n\n  var self = this;\n\n  if (!this.pc.remoteDescription) {\n    // the old API is used, call handleOffer\n    throw new Error('remoteDescription not set');\n  }\n\n  if (this.pc.signalingState === 'closed') return cb('Already closed');\n  self.pc.createAnswer(constraints).then(function (answer) {\n    var sim = [];\n\n    if (self.enableChromeNativeSimulcast) {\n      // native simulcast part 1: add another SSRC\n      answer.jingle = SJJ.toSessionJSON(answer.sdp, {\n        role: self._role(),\n        direction: 'outgoing'\n      });\n\n      if (answer.jingle.contents.length >= 2 && answer.jingle.contents[1].name === 'video') {\n        var groups = answer.jingle.contents[1].application.sourceGroups || [];\n        var hasSim = false;\n        groups.forEach(function (group) {\n          if (group.semantics == 'SIM') hasSim = true;\n        });\n\n        if (!hasSim && answer.jingle.contents[1].application.sources.length) {\n          var newssrc = JSON.parse(JSON.stringify(answer.jingle.contents[1].application.sources[0]));\n          newssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts\n\n          answer.jingle.contents[1].application.sources.push(newssrc);\n          sim.push(answer.jingle.contents[1].application.sources[0].ssrc);\n          sim.push(newssrc.ssrc);\n          groups.push({\n            semantics: 'SIM',\n            sources: sim\n          }); // also create an RTX one for the SIM one\n\n          var rtxssrc = JSON.parse(JSON.stringify(newssrc));\n          rtxssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts\n\n          answer.jingle.contents[1].application.sources.push(rtxssrc);\n          groups.push({\n            semantics: 'FID',\n            sources: [newssrc.ssrc, rtxssrc.ssrc]\n          });\n          answer.jingle.contents[1].application.sourceGroups = groups;\n          answer.sdp = SJJ.toSessionSDP(answer.jingle, {\n            sid: self.config.sdpSessionID,\n            role: self._role(),\n            direction: 'outgoing'\n          });\n        }\n      }\n    }\n\n    var expandedAnswer = {\n      type: 'answer',\n      sdp: answer.sdp\n    };\n\n    if (self.assumeSetLocalSuccess) {\n      // not safe to do when doing simulcast mangling\n      var copy = cloneDeep(expandedAnswer);\n      self.emit('answer', copy);\n      cb(null, copy);\n    }\n\n    self._candidateBuffer = [];\n    self.pc.setLocalDescription(answer).then(function () {\n      if (self.config.useJingle) {\n        var jingle = SJJ.toSessionJSON(answer.sdp, {\n          role: self._role(),\n          direction: 'outgoing'\n        });\n        jingle.sid = self.config.sid;\n        self.localDescription = jingle;\n        expandedAnswer.jingle = jingle;\n      }\n\n      if (self.enableChromeNativeSimulcast) {\n        // native simulcast part 2:\n        // signal multiple tracks to the receiver\n        // for anything in the SIM group\n        if (!expandedAnswer.jingle) {\n          expandedAnswer.jingle = SJJ.toSessionJSON(answer.sdp, {\n            role: self._role(),\n            direction: 'outgoing'\n          });\n        }\n\n        expandedAnswer.jingle.contents[1].application.sources.forEach(function (source, idx) {\n          // the floor idx/2 is a hack that relies on a particular order\n          // of groups, alternating between sim and rtx\n          source.parameters = source.parameters.map(function (parameter) {\n            if (parameter.key === 'msid') {\n              parameter.value += '-' + Math.floor(idx / 2);\n            }\n\n            return parameter;\n          });\n        });\n        expandedAnswer.sdp = SJJ.toSessionSDP(expandedAnswer.jingle, {\n          sid: self.sdpSessionID,\n          role: self._role(),\n          direction: 'outgoing'\n        });\n      }\n\n      expandedAnswer.sdp.split(/\\r?\\n/).forEach(function (line) {\n        if (line.indexOf('a=candidate:') === 0) {\n          self._checkLocalCandidate(line);\n        }\n      });\n\n      if (!self.assumeSetLocalSuccess) {\n        var copy = cloneDeep(expandedAnswer);\n        self.emit('answer', copy);\n        cb(null, copy);\n      }\n    }, function (err) {\n      self.emit('error', err);\n      cb(err);\n    });\n  }, function (err) {\n    self.emit('error', err);\n    cb(err);\n  });\n}; // Internal method for emitting ice candidates on our peer object\n\n\nPeerConnection.prototype._onIce = function (event) {\n  var self = this;\n\n  if (event.candidate) {\n    if (this.dontSignalCandidates) return;\n    var ice = event.candidate;\n    var expandedCandidate = {\n      candidate: {\n        candidate: ice.candidate,\n        sdpMid: ice.sdpMid,\n        sdpMLineIndex: ice.sdpMLineIndex\n      }\n    };\n\n    this._checkLocalCandidate(ice.candidate);\n\n    var cand = SJJ.toCandidateJSON(ice.candidate);\n    var already;\n    var idx;\n\n    if (this.eliminateDuplicateCandidates && cand.type === 'relay') {\n      // drop candidates with same foundation, component\n      // take local type pref into account so we don't ignore udp\n      // ones when we know about a TCP one. unlikely but...\n      already = this._candidateBuffer.filter(function (c) {\n        return c.type === 'relay';\n      }).map(function (c) {\n        return c.foundation + ':' + c.component;\n      });\n      idx = already.indexOf(cand.foundation + ':' + cand.component); // remember: local type pref of udp is 0, tcp 1, tls 2\n\n      if (idx > -1 && cand.priority >> 24 >= already[idx].priority >> 24) {\n        // drop it, same foundation with higher (worse) type pref\n        return;\n      }\n    }\n\n    if (this.config.bundlePolicy === 'max-bundle') {\n      // drop candidates which are duplicate for audio/video/data\n      // duplicate means same host/port but different sdpMid\n      already = this._candidateBuffer.filter(function (c) {\n        return cand.type === c.type;\n      }).map(function (cand) {\n        return cand.address + ':' + cand.port;\n      });\n      idx = already.indexOf(cand.address + ':' + cand.port);\n      if (idx > -1) return;\n    } // also drop rtcp candidates since we know the peer supports RTCP-MUX\n    // this is a workaround until browsers implement this natively\n\n\n    if (this.config.rtcpMuxPolicy === 'require' && cand.component === '2') {\n      return;\n    }\n\n    this._candidateBuffer.push(cand);\n\n    if (self.config.useJingle) {\n      if (!ice.sdpMid) {\n        // firefox doesn't set this\n        if (self.pc.remoteDescription && self.pc.remoteDescription.type === 'offer') {\n          // preserve name from remote\n          ice.sdpMid = self.remoteDescription.contents[ice.sdpMLineIndex].name;\n        } else {\n          ice.sdpMid = self.localDescription.contents[ice.sdpMLineIndex].name;\n        }\n      }\n\n      if (!self.iceCredentials.local[ice.sdpMid]) {\n        var jingle = SJJ.toSessionJSON(self.pc.localDescription.sdp, {\n          role: self._role(),\n          direction: 'outgoing'\n        });\n        jingle.contents.forEach(function (content) {\n          var transport = content.transport || {};\n\n          if (transport.ufrag) {\n            self.iceCredentials.local[content.name] = {\n              ufrag: transport.ufrag,\n              pwd: transport.pwd\n            };\n          }\n        });\n      }\n\n      expandedCandidate.jingle = {\n        contents: [{\n          name: ice.sdpMid,\n          creator: self._role(),\n          transport: {\n            transportType: 'iceUdp',\n            ufrag: self.iceCredentials.local[ice.sdpMid].ufrag,\n            pwd: self.iceCredentials.local[ice.sdpMid].pwd,\n            candidates: [cand]\n          }\n        }]\n      };\n\n      if (self.batchIceCandidates > 0) {\n        if (self.batchedIceCandidates.length === 0) {\n          window.setTimeout(function () {\n            var contents = {};\n            self.batchedIceCandidates.forEach(function (content) {\n              content = content.contents[0];\n              if (!contents[content.name]) contents[content.name] = content;\n              contents[content.name].transport.candidates.push(content.transport.candidates[0]);\n            });\n            var newCand = {\n              jingle: {\n                contents: []\n              }\n            };\n            Object.keys(contents).forEach(function (name) {\n              newCand.jingle.contents.push(contents[name]);\n            });\n            self.batchedIceCandidates = [];\n            self.emit('ice', newCand);\n          }, self.batchIceCandidates);\n        }\n\n        self.batchedIceCandidates.push(expandedCandidate.jingle);\n        return;\n      }\n    }\n\n    this.emit('ice', expandedCandidate);\n  } else {\n    this.emit('endOfCandidates');\n  }\n}; // Internal method for processing a new data channel being added by the\n// other peer.\n\n\nPeerConnection.prototype._onDataChannel = function (event) {\n  // make sure we keep a reference so this doesn't get garbage collected\n  var channel = event.channel;\n\n  this._remoteDataChannels.push(channel);\n\n  this.emit('addChannel', channel);\n}; // Create a data channel spec reference:\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannelInit\n\n\nPeerConnection.prototype.createDataChannel = function (name, opts) {\n  var channel = this.pc.createDataChannel(name, opts); // make sure we keep a reference so this doesn't get garbage collected\n\n  this._localDataChannels.push(channel);\n\n  return channel;\n};\n\nPeerConnection.prototype.getStats = function () {\n  if (typeof arguments[0] === 'function') {\n    var cb = arguments[0];\n    this.pc.getStats().then(function (res) {\n      cb(null, res);\n    }, function (err) {\n      cb(err);\n    });\n  } else {\n    return this.pc.getStats.apply(this.pc, arguments);\n  }\n};\n\nmodule.exports = PeerConnection;","map":null,"metadata":{},"sourceType":"script"}
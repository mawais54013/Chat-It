{"ast":null,"code":"/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n'use strict';\n\nvar SDPUtils = require('sdp'); // sort tracks such that they follow an a-v-a-v...\n// pattern.\n\n\nfunction sortTracks(tracks) {\n  var audioTracks = tracks.filter(function (track) {\n    return track.kind === 'audio';\n  });\n  var videoTracks = tracks.filter(function (track) {\n    return track.kind === 'video';\n  });\n  tracks = [];\n\n  while (audioTracks.length || videoTracks.length) {\n    if (audioTracks.length) {\n      tracks.push(audioTracks.shift());\n    }\n\n    if (videoTracks.length) {\n      tracks.push(videoTracks.shift());\n    }\n  }\n\n  return tracks;\n} // Edge does not like\n// 1) stun:\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\n\n\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function (server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n\n      var isString = typeof urls === 'string';\n\n      if (isString) {\n        urls = [urls];\n      }\n\n      urls = urls.filter(function (url) {\n        var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393;\n      });\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n\n    return false;\n  });\n} // Determines the intersection of local and remote capabilities.\n\n\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function findCodecByPayloadType(pt, codecs) {\n    pt = parseInt(pt, 10);\n\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function rtxCapabilityMatches(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function (lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' && lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n\n        rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels); // push rCodec so we reply with offerer payload type\n\n        commonCapabilities.codecs.push(rCodec); // determine common feedback mechanisms\n\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n\n          return false;\n        }); // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n\n        break;\n      }\n    }\n  });\n  localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  }); // FIXME: fecMechanisms\n\n  return commonCapabilities;\n} // is action=setLocalDescription with type allowed in signalingState\n\n\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nmodule.exports = function (window, edgeVersion) {\n  var RTCPeerConnection = function RTCPeerConnection(config) {\n    var self = this;\n\n    var _eventTarget = document.createDocumentFragment();\n\n    ['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function (method) {\n      self[method] = _eventTarget[method].bind(_eventTarget);\n    });\n    this.needNegotiation = false;\n    this.onicecandidate = null;\n    this.onaddstream = null;\n    this.ontrack = null;\n    this.onremovestream = null;\n    this.onsignalingstatechange = null;\n    this.oniceconnectionstatechange = null;\n    this.onicegatheringstatechange = null;\n    this.onnegotiationneeded = null;\n    this.ondatachannel = null;\n    this.canTrickleIceCandidates = null;\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this.getLocalStreams = function () {\n      return self.localStreams;\n    };\n\n    this.getRemoteStreams = function () {\n      return self.remoteStreams;\n    };\n\n    this.localDescription = new window.RTCSessionDescription({\n      type: '',\n      sdp: ''\n    });\n    this.remoteDescription = new window.RTCSessionDescription({\n      type: '',\n      sdp: ''\n    });\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.iceGatheringState = 'new';\n    this.iceOptions = {\n      gatherPolicy: 'all',\n      iceServers: []\n    };\n\n    if (config && config.iceTransportPolicy) {\n      switch (config.iceTransportPolicy) {\n        case 'all':\n        case 'relay':\n          this.iceOptions.gatherPolicy = config.iceTransportPolicy;\n          break;\n\n        default:\n          // don't set iceTransportPolicy.\n          break;\n      }\n    }\n\n    this.usingBundle = config && config.bundlePolicy === 'max-bundle';\n\n    if (config && config.iceServers) {\n      this.iceOptions.iceServers = filterIceServers(config.iceServers, edgeVersion);\n    }\n\n    this._config = config || {}; // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n\n    this.transceivers = []; // since the iceGatherer is currently created in createOffer but we\n    // must not emit candidates until after setLocalDescription we buffer\n    // them in this array.\n\n    this._localIceCandidatesBuffer = [];\n    this._sdpSessionId = SDPUtils.generateSessionId();\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function () {\n    var event = new Event('icegatheringstatechange');\n    this.dispatchEvent(event);\n\n    if (this.onicegatheringstatechange !== null) {\n      this.onicegatheringstatechange(event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitBufferedCandidates = function () {\n    var self = this;\n    var sections = SDPUtils.splitSections(self.localDescription.sdp); // FIXME: need to apply ice candidates in a way which is async but\n    // in-order\n\n    this._localIceCandidatesBuffer.forEach(function (event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n\n      if (end) {\n        for (var j = 1; j < sections.length; j++) {\n          if (sections[j].indexOf('\\r\\na=end-of-candidates\\r\\n') === -1) {\n            sections[j] += 'a=end-of-candidates\\r\\n';\n          }\n        }\n      } else {\n        sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n';\n      }\n\n      self.localDescription.sdp = sections.join('');\n      self.dispatchEvent(event);\n\n      if (self.onicecandidate !== null) {\n        self.onicecandidate(event);\n      }\n\n      if (!event.candidate && self.iceGatheringState !== 'complete') {\n        var complete = self.transceivers.every(function (transceiver) {\n          return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';\n        });\n\n        if (complete && self.iceGatheringStateChange !== 'complete') {\n          self.iceGatheringState = 'complete';\n\n          self._emitGatheringStateChange();\n        }\n      }\n    });\n\n    this._localIceCandidatesBuffer = [];\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function () {\n    return this._config;\n  }; // internal helper to create a transceiver object.\n  // (whih is not yet the same as the WebRTC 1.0 transceiver)\n\n\n  RTCPeerConnection.prototype._createTransceiver = function (kind) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      wantReceive: true\n    };\n\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n\n    this.transceivers.push(transceiver);\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function (track, stream) {\n    var transceiver;\n\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport);\n\n    this._maybeFireNegotiationNeeded();\n\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function (stream) {\n    var self = this;\n\n    if (edgeVersion >= 15025) {\n      this.localStreams.push(stream);\n      stream.getTracks().forEach(function (track) {\n        self.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function (track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function (event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function (track) {\n        self.addTrack(track, clonedStream);\n      });\n      this.localStreams.push(clonedStream);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function (stream) {\n    var idx = this.localStreams.indexOf(stream);\n\n    if (idx > -1) {\n      this.localStreams.splice(idx, 1);\n\n      this._maybeFireNegotiationNeeded();\n    }\n  };\n\n  RTCPeerConnection.prototype.getSenders = function () {\n    return this.transceivers.filter(function (transceiver) {\n      return !!transceiver.rtpSender;\n    }).map(function (transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function () {\n    return this.transceivers.filter(function (transceiver) {\n      return !!transceiver.rtpReceiver;\n    }).map(function (transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  }; // Create ICE gatherer and hook it up.\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function (mid, sdpMLineIndex) {\n    var self = this;\n    var iceGatherer = new window.RTCIceGatherer(self.iceOptions);\n\n    iceGatherer.onlocalcandidate = function (evt) {\n      var event = new Event('icecandidate');\n      event.candidate = {\n        sdpMid: mid,\n        sdpMLineIndex: sdpMLineIndex\n      };\n      var cand = evt.candidate;\n      var end = !cand || Object.keys(cand).length === 0; // Edge emits an empty object for RTCIceCandidateComplete‥\n\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === undefined) {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        event.candidate.candidate = SDPUtils.writeCandidate(cand);\n      } // update local description.\n\n\n      var sections = SDPUtils.splitSections(self.localDescription.sdp);\n\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex + 1] += 'a=end-of-candidates\\r\\n';\n      }\n\n      self.localDescription.sdp = sections.join('');\n      var transceivers = self._pendingOffer ? self._pendingOffer : self.transceivers;\n      var complete = transceivers.every(function (transceiver) {\n        return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';\n      }); // Emit candidate if localDescription is set.\n      // Also emits null candidate when all gatherers are complete.\n\n      switch (self.iceGatheringState) {\n        case 'new':\n          if (!end) {\n            self._localIceCandidatesBuffer.push(event);\n          }\n\n          if (end && complete) {\n            self._localIceCandidatesBuffer.push(new Event('icecandidate'));\n          }\n\n          break;\n\n        case 'gathering':\n          self._emitBufferedCandidates();\n\n          if (!end) {\n            self.dispatchEvent(event);\n\n            if (self.onicecandidate !== null) {\n              self.onicecandidate(event);\n            }\n          }\n\n          if (complete) {\n            self.dispatchEvent(new Event('icecandidate'));\n\n            if (self.onicecandidate !== null) {\n              self.onicecandidate(new Event('icecandidate'));\n            }\n\n            self.iceGatheringState = 'complete';\n\n            self._emitGatheringStateChange();\n          }\n\n          break;\n\n        case 'complete':\n          // should not happen... currently!\n          break;\n\n        default:\n          // no-op.\n          break;\n      }\n    };\n\n    return iceGatherer;\n  }; // Create ICE transport and DTLS transport.\n\n\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {\n    var self = this;\n    var iceTransport = new window.RTCIceTransport(null);\n\n    iceTransport.onicestatechange = function () {\n      self._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n\n    dtlsTransport.ondtlsstatechange = function () {\n      self._updateConnectionState();\n    };\n\n    dtlsTransport.onerror = function () {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state', {\n        value: 'failed',\n        writable: true\n      });\n\n      self._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  }; // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n\n\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  }; // Start the RTP Sender and Receiver for a transceiver.\n\n\n  RTCPeerConnection.prototype._transceive = function (transceiver, send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n\n      transceiver.rtpSender.send(params);\n    }\n\n    if (recv && transceiver.rtpReceiver) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video' && transceiver.recvEncodingParameters && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function (p) {\n          delete p.rtx;\n        });\n      }\n\n      params.encodings = transceiver.recvEncodingParameters;\n      params.rtcp = {\n        cname: transceiver.rtcpParameters.cname,\n        compound: transceiver.rtcpParameters.compound\n      };\n\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function (description) {\n    var self = this;\n\n    if (!isActionAllowedInSignalingState('setLocalDescription', description.type, this.signalingState)) {\n      var e = new Error('Can not set local ' + description.type + ' in state ' + this.signalingState);\n      e.name = 'InvalidStateError';\n\n      if (arguments.length > 2 && typeof arguments[2] === 'function') {\n        window.setTimeout(arguments[2], 0, e);\n      }\n\n      return Promise.reject(e);\n    }\n\n    var sections;\n    var sessionpart;\n\n    if (description.type === 'offer') {\n      // FIXME: What was the purpose of this empty if statement?\n      // if (!this._pendingOffer) {\n      // } else {\n      if (this._pendingOffer) {\n        // VERY limited support for SDP munging. Limited to:\n        // * changing the order of codecs\n        sections = SDPUtils.splitSections(description.sdp);\n        sessionpart = sections.shift();\n        sections.forEach(function (mediaSection, sdpMLineIndex) {\n          var caps = SDPUtils.parseRtpParameters(mediaSection);\n          self._pendingOffer[sdpMLineIndex].localCapabilities = caps;\n        });\n        this.transceivers = this._pendingOffer;\n        delete this._pendingOffer;\n      }\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(self.remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;\n      sections.forEach(function (mediaSection, sdpMLineIndex) {\n        var transceiver = self.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n        var rejected = SDPUtils.isRejected(mediaSection);\n\n        if (!rejected && !transceiver.isDatachannel) {\n          var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);\n\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!self.usingBundle || sdpMLineIndex === 0) {\n            iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled');\n            dtlsTransport.start(remoteDtlsParameters);\n          } // Calculate intersection of capabilities.\n\n\n          var params = getCommonCapabilities(localCapabilities, remoteCapabilities); // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n\n          self._transceive(transceiver, params.codecs.length > 0, false);\n        }\n      });\n    }\n\n    this.localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n\n    switch (description.type) {\n      case 'offer':\n        this._updateSignalingState('have-local-offer');\n\n        break;\n\n      case 'answer':\n        this._updateSignalingState('stable');\n\n        break;\n\n      default:\n        throw new TypeError('unsupported type \"' + description.type + '\"');\n    } // If a success callback was provided, emit ICE candidates after it\n    // has been executed. Otherwise, emit callback after the Promise is\n    // resolved.\n\n\n    var hasCallback = arguments.length > 1 && typeof arguments[1] === 'function';\n\n    if (hasCallback) {\n      var cb = arguments[1];\n      window.setTimeout(function () {\n        cb();\n\n        if (self.iceGatheringState === 'new') {\n          self.iceGatheringState = 'gathering';\n\n          self._emitGatheringStateChange();\n        }\n\n        self._emitBufferedCandidates();\n      }, 0);\n    }\n\n    var p = Promise.resolve();\n    p.then(function () {\n      if (!hasCallback) {\n        if (self.iceGatheringState === 'new') {\n          self.iceGatheringState = 'gathering';\n\n          self._emitGatheringStateChange();\n        } // Usually candidates will be emitted earlier.\n\n\n        window.setTimeout(self._emitBufferedCandidates.bind(self), 500);\n      }\n    });\n    return p;\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function (description) {\n    var self = this;\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, this.signalingState)) {\n      var e = new Error('Can not set remote ' + description.type + ' in state ' + this.signalingState);\n      e.name = 'InvalidStateError';\n\n      if (arguments.length > 2 && typeof arguments[2] === 'function') {\n        window.setTimeout(arguments[2], 0, e);\n      }\n\n      return Promise.reject(e);\n    }\n\n    var streams = {};\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;\n    this.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0];\n\n    if (iceOptions) {\n      this.canTrickleIceCandidates = iceOptions.substr(14).split(' ').indexOf('trickle') >= 0;\n    } else {\n      this.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function (mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      var rejected = SDPUtils.isRejected(mediaSection);\n      var protocol = lines[0].substr(2).split(' ')[2];\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier(); // Reject datachannels which are not implemented yet.\n\n      if (kind === 'application' && protocol === 'DTLS/SCTP') {\n        self.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          isDatachannel: true\n        };\n        return;\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n      var track; // FIXME: ensure the mediaSection has rtcp-mux set.\n\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n\n      recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n      var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function (cand) {\n        return SDPUtils.parseCandidate(cand);\n      }).filter(function (cand) {\n        return cand.component === '1' || cand.component === 1;\n      }); // Check if we can use BUNDLE and dispose transports.\n\n      if ((description.type === 'offer' || description.type === 'answer') && !rejected && usingBundle && sdpMLineIndex > 0 && self.transceivers[sdpMLineIndex]) {\n        self._disposeIceAndDtlsTransports(sdpMLineIndex);\n\n        self.transceivers[sdpMLineIndex].iceGatherer = self.transceivers[0].iceGatherer;\n        self.transceivers[sdpMLineIndex].iceTransport = self.transceivers[0].iceTransport;\n        self.transceivers[sdpMLineIndex].dtlsTransport = self.transceivers[0].dtlsTransport;\n\n        if (self.transceivers[sdpMLineIndex].rtpSender) {\n          self.transceivers[sdpMLineIndex].rtpSender.setTransport(self.transceivers[0].dtlsTransport);\n        }\n\n        if (self.transceivers[sdpMLineIndex].rtpReceiver) {\n          self.transceivers[sdpMLineIndex].rtpReceiver.setTransport(self.transceivers[0].dtlsTransport);\n        }\n      }\n\n      if (description.type === 'offer' && !rejected) {\n        transceiver = self.transceivers[sdpMLineIndex] || self._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = usingBundle && sdpMLineIndex > 0 ? self.transceivers[0].iceGatherer : self._createIceGatherer(mid, sdpMLineIndex);\n        }\n\n        if (isComplete && cands.length && (!usingBundle || sdpMLineIndex === 0)) {\n          transceiver.iceTransport.setRemoteCandidates(cands);\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {\n            return codec.name !== 'rtx';\n          });\n        }\n\n        sendEncodingParameters = [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n          track = rtpReceiver.track; // FIXME: does not work with Plan B.\n\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n              Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                get: function get() {\n                  return remoteMsid.stream;\n                }\n              });\n            }\n\n            Object.defineProperty(track, 'id', {\n              get: function get() {\n                return remoteMsid.track;\n              }\n            });\n            streams[remoteMsid.stream].addTrack(track);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n\n            streams.default.addTrack(track);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters; // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n\n        self._transceive(self.transceivers[sdpMLineIndex], false, direction === 'sendrecv' || direction === 'sendonly');\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = self.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n        self.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;\n        self.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;\n        self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if ((isIceLite || isComplete) && cands.length) {\n            iceTransport.setRemoteCandidates(cands);\n          }\n\n          iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');\n          dtlsTransport.start(remoteDtlsParameters);\n        }\n\n        self._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly');\n\n        if (rtpReceiver && (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n\n            streams[remoteMsid.stream].addTrack(track);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n\n            streams.default.addTrack(track);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n    this.remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n\n    switch (description.type) {\n      case 'offer':\n        this._updateSignalingState('have-remote-offer');\n\n        break;\n\n      case 'answer':\n        this._updateSignalingState('stable');\n\n        break;\n\n      default:\n        throw new TypeError('unsupported type \"' + description.type + '\"');\n    }\n\n    Object.keys(streams).forEach(function (sid) {\n      var stream = streams[sid];\n\n      if (stream.getTracks().length) {\n        self.remoteStreams.push(stream);\n        var event = new Event('addstream');\n        event.stream = stream;\n        self.dispatchEvent(event);\n\n        if (self.onaddstream !== null) {\n          window.setTimeout(function () {\n            self.onaddstream(event);\n          }, 0);\n        }\n\n        receiverList.forEach(function (item) {\n          var track = item[0];\n          var receiver = item[1];\n\n          if (stream.id !== item[2].id) {\n            return;\n          }\n\n          var trackEvent = new Event('track');\n          trackEvent.track = track;\n          trackEvent.receiver = receiver;\n          trackEvent.streams = [stream];\n          self.dispatchEvent(trackEvent);\n\n          if (self.ontrack !== null) {\n            window.setTimeout(function () {\n              self.ontrack(trackEvent);\n            }, 0);\n          }\n        });\n      }\n    }); // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n\n    window.setTimeout(function () {\n      if (!(self && self.transceivers)) {\n        return;\n      }\n\n      self.transceivers.forEach(function (transceiver) {\n        if (transceiver.iceTransport && transceiver.iceTransport.state === 'new' && transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    if (arguments.length > 1 && typeof arguments[1] === 'function') {\n      window.setTimeout(arguments[1], 0);\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function () {\n    this.transceivers.forEach(function (transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    }); // FIXME: clean up tracks, local streams, remote streams, etc\n\n    this._updateSignalingState('closed');\n  }; // Update the signaling state.\n\n\n  RTCPeerConnection.prototype._updateSignalingState = function (newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this.dispatchEvent(event);\n\n    if (this.onsignalingstatechange !== null) {\n      this.onsignalingstatechange(event);\n    }\n  }; // Determine whether to fire the negotiationneeded event.\n\n\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {\n    var self = this;\n\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n\n    this.needNegotiation = true;\n    window.setTimeout(function () {\n      if (self.needNegotiation === false) {\n        return;\n      }\n\n      self.needNegotiation = false;\n      var event = new Event('negotiationneeded');\n      self.dispatchEvent(event);\n\n      if (self.onnegotiationneeded !== null) {\n        self.onnegotiationneeded(event);\n      }\n    }, 0);\n  }; // Update the connection state.\n\n\n  RTCPeerConnection.prototype._updateConnectionState = function () {\n    var self = this;\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function (transceiver) {\n      states[transceiver.iceTransport.state]++;\n      states[transceiver.dtlsTransport.state]++;\n    }); // ICETransport.completed and connected are the same for this purpose.\n\n    states.connected += states.completed;\n    newState = 'new';\n\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0 || states.checking > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0 || states.completed > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== self.iceConnectionState) {\n      self.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this.dispatchEvent(event);\n\n      if (this.oniceconnectionstatechange !== null) {\n        this.oniceconnectionstatechange(event);\n      }\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function () {\n    var self = this;\n\n    if (this._pendingOffer) {\n      throw new Error('createOffer called while there is a pending offer.');\n    }\n\n    var offerOptions;\n\n    if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n      offerOptions = arguments[0];\n    } else if (arguments.length === 3) {\n      offerOptions = arguments[2];\n    }\n\n    var numAudioTracks = this.transceivers.filter(function (t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = this.transceivers.filter(function (t) {\n      return t.kind === 'video';\n    }).length; // Determine number of audio and video tracks we need to send/recv.\n\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError('Legacy mandatory/optional constraints not supported.');\n      }\n\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    this.transceivers.forEach(function (transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    }); // Create M-lines for recvonly streams.\n\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        this._createTransceiver('audio');\n\n        numAudioTracks--;\n      }\n\n      if (numVideoTracks > 0) {\n        this._createTransceiver('video');\n\n        numVideoTracks--;\n      }\n    } // reorder tracks\n\n\n    var transceivers = sortTracks(this.transceivers);\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);\n    transceivers.forEach(function (transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = self.usingBundle && sdpMLineIndex > 0 ? transceivers[0].iceGatherer : self._createIceGatherer(mid, sdpMLineIndex);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {\n          return codec.name !== 'rtx';\n        });\n      }\n\n      localCapabilities.codecs.forEach(function (codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' && codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n      }); // generate an ssrc now, to be used later in rtpSender.send\n\n      var sendEncodingParameters = [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video') {\n          sendEncodingParameters[0].rtx = {\n            ssrc: (2 * sdpMLineIndex + 1) * 1001 + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    }); // always offer BUNDLE and dispose on return if not supported.\n\n    if (this._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + transceivers.map(function (t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n\n    sdp += 'a=ice-options:trickle\\r\\n';\n    transceivers.forEach(function (transceiver, sdpMLineIndex) {\n      sdp += SDPUtils.writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream);\n      sdp += 'a=rtcp-rsize\\r\\n';\n    });\n    this._pendingOffer = transceivers;\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n\n    if (arguments.length && typeof arguments[0] === 'function') {\n      window.setTimeout(arguments[0], 0, desc);\n    }\n\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function () {\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);\n\n    if (this.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function (t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n\n    this.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n      if (transceiver.isDatachannel) {\n        sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n' + 'c=IN IP4 0.0.0.0\\r\\n' + 'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      } // FIXME: look at direction.\n\n\n      if (transceiver.stream) {\n        var localTrack;\n\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video') {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: (2 * sdpMLineIndex + 2) * 1001 + 1\n            };\n          }\n        }\n      } // Calculate intersection of capabilities.\n\n\n      var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n      var hasRtx = commonCapabilities.codecs.filter(function (c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream);\n\n      if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n\n    if (arguments.length && typeof arguments[0] === 'function') {\n      window.setTimeout(arguments[0], 0, desc);\n    }\n\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n    if (!candidate) {\n      for (var j = 0; j < this.transceivers.length; j++) {\n        this.transceivers[j].iceTransport.addRemoteCandidate({});\n\n        if (this.usingBundle) {\n          return Promise.resolve();\n        }\n      }\n    } else {\n      var mLineIndex = candidate.sdpMLineIndex;\n\n      if (candidate.sdpMid) {\n        for (var i = 0; i < this.transceivers.length; i++) {\n          if (this.transceivers[i].mid === candidate.sdpMid) {\n            mLineIndex = i;\n            break;\n          }\n        }\n      }\n\n      var transceiver = this.transceivers[mLineIndex];\n\n      if (transceiver) {\n        var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {}; // Ignore Chrome's invalid candidates since Edge does not like them.\n\n        if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n          return Promise.resolve();\n        } // Ignore RTCP candidates, we assume RTCP-MUX.\n\n\n        if (cand.component && !(cand.component === '1' || cand.component === 1)) {\n          return Promise.resolve();\n        }\n\n        transceiver.iceTransport.addRemoteCandidate(cand); // update the remoteDescription.\n\n        var sections = SDPUtils.splitSections(this.remoteDescription.sdp);\n        sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim() : 'a=end-of-candidates') + '\\r\\n';\n        this.remoteDescription.sdp = sections.join('');\n      }\n    }\n\n    if (arguments.length > 1 && typeof arguments[1] === 'function') {\n      window.setTimeout(arguments[1], 0);\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.getStats = function () {\n    var promises = [];\n    this.transceivers.forEach(function (transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function (method) {\n        if (transceiver[method]) {\n          promises.push(transceiver[method].getStats());\n        }\n      });\n    });\n    var cb = arguments.length > 1 && typeof arguments[1] === 'function' && arguments[1];\n\n    var fixStatsType = function fixStatsType(stat) {\n      return {\n        inboundrtp: 'inbound-rtp',\n        outboundrtp: 'outbound-rtp',\n        candidatepair: 'candidate-pair',\n        localcandidate: 'local-candidate',\n        remotecandidate: 'remote-candidate'\n      }[stat.type] || stat.type;\n    };\n\n    return new Promise(function (resolve) {\n      // shim getStats with maplike support\n      var results = new Map();\n      Promise.all(promises).then(function (res) {\n        res.forEach(function (result) {\n          Object.keys(result).forEach(function (id) {\n            result[id].type = fixStatsType(result[id]);\n            results.set(id, result[id]);\n          });\n        });\n\n        if (cb) {\n          window.setTimeout(cb, 0, results);\n        }\n\n        resolve(results);\n      });\n    });\n  };\n\n  return RTCPeerConnection;\n};","map":null,"metadata":{},"sourceType":"script"}
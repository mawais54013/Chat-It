{"ast":null,"code":"/**\n * Parse arguments.\n * @constructor Argx\n * @param {Arguments} args - Function arguments\n */\n'use strict';\n\nvar iftype = require('iftype');\n\nvar isNumber = require('./type/is_number');\n/** @lends constructor */\n\n\nfunction Argx(args) {\n  var s = this;\n  s.values = Array.prototype.slice.call(args, 0);\n}\n\nArgx.prototype = {\n  /**\n   * Splice argument values.\n   * @param {number} start - Where to start\n   * @param {number} [howmany=1] - Number of value to get.\n   * @param {string} [type] - Type restriction.\n   */\n  splice: function splice(start, howmany, type) {\n    var s = this;\n\n    if (typeof arguments[1] !== 'number') {\n      if (isNumber(arguments[1])) {\n        howmany = Number(arguments[1]);\n      } else {\n        type = arguments[1];\n        howmany = 1;\n      }\n    }\n\n    howmany = howmany || 1;\n\n    if (start < 0) {\n      start += s.values.length;\n    }\n\n    var result;\n    var hitCount = 0;\n\n    for (var i = start + howmany - 1; i >= start; i--) {\n      var skipByType = type && !iftype(s.values[i]).is(type);\n\n      if (skipByType) {\n        break;\n      }\n\n      var spliced = s.values.splice(i, 1);\n\n      if (!spliced.length) {\n        break;\n      }\n\n      spliced = spliced[0];\n\n      switch (hitCount) {\n        case 0:\n          result = spliced;\n          break;\n\n        case 1:\n          result = [spliced, result];\n          break;\n\n        default:\n          result.unshift(spliced);\n          break;\n      }\n\n      hitCount += 1;\n    }\n\n    return result;\n  },\n\n  /**\n   * Pop values\n   * @param {number|string} [howmany=1] - Number of value to get.\n   * @param {string|function} [type] - Type restriction. Could be a name of type or a constructor.\n   * @returns {*} - Value. Array if multiple hits.\n   * @example\n   *  function doSomething() {\n     *      let args = argx(arguments)\n     *      args.pop()\n     *      args.pop(2)\n     *      args.pop('string')\n     *      args.pop(MyCustomError)\n     *  }\n   */\n  pop: function pop(howmany, type) {\n    var s = this;\n    var from = -Number(howmany);\n\n    if (isNaN(from)) {\n      from = -1;\n    }\n\n    return s.splice(from, howmany, type);\n  },\n\n  /**\n   * Shift values\n   * @param {number|string} [howmany=1] - Number of value to get.\n   * @param {string} [type] - Type restriction. Could be a name of type or a constructor.\n   * @returns {*} - Value. Array if multiple hits.\n   * @example\n   *  function doSomething() {\n     *      let args = argx(arguments)\n     *      args.shift()\n     *      args.shift(2)\n     *      args.shift('string')\n     *      args.shift(MyCustomError)\n     *  }\n   */\n  shift: function shift(howmany, type) {\n    var s = this;\n    return s.splice(0, howmany, type);\n  },\n\n  /**\n   * Get all remain values.\n   * @returns {Array}\n   */\n  remain: function remain() {\n    var s = this;\n    var values = s.values;\n    s.values = [];\n    return values;\n  }\n};\nmodule.exports = Argx;","map":null,"metadata":{},"sourceType":"script"}
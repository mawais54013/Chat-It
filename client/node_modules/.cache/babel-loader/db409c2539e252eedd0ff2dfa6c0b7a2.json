{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _rtcpeerconnection = require('rtcpeerconnection');\n\nvar _rtcpeerconnection2 = _interopRequireDefault(_rtcpeerconnection);\n\nvar _wildemitter = require('wildemitter');\n\nvar _wildemitter2 = _interopRequireDefault(_wildemitter);\n\nvar _filetransfer = require('filetransfer');\n\nvar _filetransfer2 = _interopRequireDefault(_filetransfer);\n\nvar _webrtcsupport = require('./webrtcsupport');\n\nvar _webrtcsupport2 = _interopRequireDefault(_webrtcsupport);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction isAllTracksEnded(stream) {\n  var isAllTracksEnded = true;\n  stream.getTracks().forEach(function (t) {\n    isAllTracksEnded = t.readyState === 'ended' && isAllTracksEnded;\n  });\n  return isAllTracksEnded;\n}\n\nvar Peer = function (_WildEmitter) {\n  _inherits(Peer, _WildEmitter);\n\n  function Peer(options) {\n    _classCallCheck(this, Peer);\n\n    var _this = _possibleConstructorReturn(this, (Peer.__proto__ || Object.getPrototypeOf(Peer)).call(this));\n\n    var self = _this;\n    _this.id = options.id;\n    _this.parent = options.parent;\n    _this.type = options.type || 'video';\n    _this.oneway = options.oneway || false;\n    _this.sharemyscreen = options.sharemyscreen || false;\n    _this.browserPrefix = options.prefix;\n    _this.stream = options.stream;\n    _this.enableDataChannels = options.enableDataChannels === undefined ? _this.parent.config.enableDataChannels : options.enableDataChannels;\n    _this.receiveMedia = options.receiveMedia || _this.parent.config.receiveMedia;\n    _this.channels = {};\n    _this.sid = options.sid || Date.now().toString(); // Create an RTCPeerConnection via the polyfill\n\n    _this.pc = new _rtcpeerconnection2.default(_this.parent.config.peerConnectionConfig, _this.parent.config.peerConnectionConstraints);\n\n    _this.pc.on('ice', _this.onIceCandidate.bind(_this));\n\n    _this.pc.on('endOfCandidates', function (event) {\n      self.send('endOfCandidates', event);\n    });\n\n    _this.pc.on('offer', function (offer) {\n      if (self.parent.config.nick) offer.nick = self.parent.config.nick;\n      self.send('offer', offer);\n    });\n\n    _this.pc.on('answer', function (answer) {\n      if (self.parent.config.nick) answer.nick = self.parent.config.nick;\n      self.send('answer', answer);\n    });\n\n    _this.pc.on('addStream', _this.handleRemoteStreamAdded.bind(_this));\n\n    _this.pc.on('addChannel', _this.handleDataChannelAdded.bind(_this));\n\n    _this.pc.on('removeStream', _this.handleStreamRemoved.bind(_this)); // Just fire negotiation needed events for now\n    // When browser re-negotiation handling seems to work\n    // we can use this as the trigger for starting the offer/answer process\n    // automatically. We'll just leave it be for now while this stabalizes.\n\n\n    _this.pc.on('negotiationNeeded', _this.emit.bind(_this, 'negotiationNeeded'));\n\n    _this.pc.on('iceConnectionStateChange', _this.emit.bind(_this, 'iceConnectionStateChange'));\n\n    _this.pc.on('iceConnectionStateChange', function () {\n      switch (self.pc.iceConnectionState) {\n        case 'failed':\n          // currently, in chrome only the initiator goes to failed\n          // so we need to signal this to the peer\n          if (self.pc.pc.localDescription.type === 'offer') {\n            self.parent.emit('iceFailed', self);\n            self.send('connectivityError');\n          }\n\n          break;\n\n        case 'closed':\n          _this.handleStreamRemoved(false);\n\n          break;\n\n        default:\n          break;\n      }\n    });\n\n    _this.pc.on('signalingStateChange', _this.emit.bind(_this, 'signalingStateChange'));\n\n    _this.logger = _this.parent.logger;\n\n    _this.parent.localStreams.forEach(function (stream) {\n      self.pc.addStream(stream);\n    });\n\n    _this.on('channelOpen', function (channel) {}); // proxy events to parent\n\n\n    _this.on('*', function () {\n      var _self$parent;\n\n      (_self$parent = self.parent).emit.apply(_self$parent, arguments);\n    });\n\n    return _this;\n  }\n\n  _createClass(Peer, [{\n    key: 'handleMessage',\n    value: function handleMessage(message) {\n      var self = this;\n      this.logger.log('getting', message.type, message);\n      if (message.prefix) this.browserPrefix = message.prefix;\n\n      if (message.type === 'offer') {\n        if (!this.nick) {\n          var n = message.payload.nick;\n          this.nick = n;\n        } // delete message.payload.nick;\n\n\n        this.pc.handleOffer(message.payload, function (err) {\n          if (err) {\n            return;\n          } // auto-accept\n\n\n          self.pc.answer(function (err, sessionDescription) {// self.send('answer', sessionDescription);\n            // console.log('answering', sessionDescription);\n          });\n        });\n      } else if (message.type === 'answer') {\n        if (!this.nick) this.nick = message.payload.nick;\n        delete message.payload.nick;\n        this.pc.handleAnswer(message.payload);\n      } else if (message.type === 'candidate') {\n        this.pc.processIce(message.payload);\n      } else if (message.type === 'connectivityError') {\n        this.parent.emit('connectivityError', self);\n      } else if (message.type === 'mute') {\n        this.parent.emit('mute', {\n          id: message.from,\n          name: message.payload.name\n        });\n      } else if (message.type === 'unmute') {\n        this.parent.emit('unmute', {\n          id: message.from,\n          name: message.payload.name\n        });\n      } else if (message.type === 'endOfCandidates') {\n        // Edge requires an end-of-candidates. Since only Edge will have mLines or tracks on the\n        // shim this will only be called in Edge.\n        var mLines = this.pc.pc.transceivers || [];\n        mLines.forEach(function (mLine) {\n          if (mLine.iceTransport) {\n            mLine.iceTransport.addRemoteCandidate({});\n          }\n        });\n      } else if (message.type === 'signalData') {\n        this.parent.emit('receivedSignalData', message.payload.type, message.payload.payload, self);\n      }\n    } // send via signaling channel\n\n  }, {\n    key: 'send',\n    value: function send(messageType, payload) {\n      var message = {\n        to: this.id,\n        sid: this.sid,\n        broadcaster: this.broadcaster,\n        roomType: this.type,\n        type: messageType,\n        payload: payload,\n        prefix: _webrtcsupport2.default.prefix,\n        timestamp: Date.now()\n      };\n      this.logger.log('sending', messageType, message);\n      this.parent.emit('message', message);\n    } // send via data channel\n    // returns true when message was sent and false if channel is not open\n\n  }, {\n    key: 'sendDirectly',\n    value: function sendDirectly(messageType, payload) {\n      var channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'liowebrtc';\n      var shout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var messageId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Date.now() + '_' + Math.random() * 1000000;\n      var message = {\n        type: messageType,\n        payload: payload,\n        _id: messageId,\n        shout: shout\n      };\n      this.logger.log('sending via datachannel', channel, messageType, message);\n      var dc = this.getDataChannel(channel);\n      if (dc.readyState !== 'open') return false;\n      dc.send(JSON.stringify(message));\n      return true;\n    } // Internal method registering handlers for a data channel and emitting events on the peer\n\n  }, {\n    key: '_observeDataChannel',\n    value: function _observeDataChannel(channel, peer) {\n      var self = this;\n      channel.onclose = this.emit.bind(this, 'channelClose', channel);\n      channel.onerror = this.emit.bind(this, 'channelError', channel);\n\n      channel.onmessage = function (event) {\n        self.emit('channelMessage', self, channel.label, JSON.parse(event.data), channel, event);\n      };\n\n      channel.onopen = this.emit.bind(this, 'channelOpen', channel, peer);\n    } // Fetch or create a data channel by the given name\n\n  }, {\n    key: 'getDataChannel',\n    value: function getDataChannel() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'liowebrtc';\n      var opts = arguments[1];\n      var channel = this.channels[name];\n      opts || (opts = {});\n      if (channel) return channel; // if we don't have one by this label, create it\n\n      channel = this.channels[name] = this.pc.createDataChannel(name, opts);\n\n      this._observeDataChannel(channel, this);\n\n      return channel;\n    }\n  }, {\n    key: 'onIceCandidate',\n    value: function onIceCandidate(candidate) {\n      if (this.closed) return;\n\n      if (candidate) {\n        var pcConfig = this.parent.config.peerConnectionConfig;\n\n        if (_webrtcsupport2.default.prefix === 'moz' && pcConfig && pcConfig.iceTransports && candidate.candidate && candidate.candidate.candidate && !candidate.candidate.candidate.includes(pcConfig.iceTransports)) {\n          this.logger.log('Ignoring ice candidate not matching pcConfig iceTransports type: ', pcConfig.iceTransports);\n        } else {\n          this.send('candidate', candidate);\n        }\n      } else {\n        this.logger.log('End of candidates.');\n      }\n    }\n  }, {\n    key: 'start',\n    value: function start() {\n      var self = this; // well, the webrtc api requires that we either\n      // a) create a datachannel a priori\n      // b) do a renegotiation later to add the SCTP m-line\n      // Let's do (a) first...\n\n      if (this.enableDataChannels) {\n        this.getDataChannel('liowebrtc');\n      }\n\n      this.pc.offer(this.receiveMedia, function (err, sessionDescription) {// self.send('offer', sessionDescription);\n      });\n    }\n  }, {\n    key: 'icerestart',\n    value: function icerestart() {\n      var constraints = this.receiveMedia;\n      constraints.mandatory.IceRestart = true;\n      this.pc.offer(constraints, function (err, success) {});\n    }\n  }, {\n    key: 'end',\n    value: function end() {\n      var emitRemoval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (this.closed) return;\n      this.pc.close();\n      this.handleStreamRemoved(emitRemoval);\n\n      if (emitRemoval) {\n        this.parent.emit('removedPeer', this);\n      }\n    }\n  }, {\n    key: 'handleRemoteStreamAdded',\n    value: function handleRemoteStreamAdded(event) {\n      var self = this;\n\n      if (this.stream) {\n        this.logger.warn('Already have a remote stream');\n      } else {\n        this.stream = event.stream;\n        this.stream.getTracks().forEach(function (track) {\n          track.addEventListener('ended', function () {\n            if (isAllTracksEnded(self.stream)) {\n              self.end();\n            }\n          });\n        });\n        this.parent.emit('peerStreamAdded', this.stream, this);\n      }\n    }\n  }, {\n    key: 'handleStreamRemoved',\n    value: function handleStreamRemoved() {\n      var emitRemoval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var peerIndex = this.parent.peers.indexOf(this);\n\n      if (peerIndex > -1) {\n        this.parent.peers.splice(peerIndex, 1);\n        this.closed = true;\n        if (emitRemoval) this.parent.emit('peerStreamRemoved', this);\n      }\n    }\n  }, {\n    key: 'handleDataChannelAdded',\n    value: function handleDataChannelAdded(channel) {\n      this.channels[channel.label] = channel; //this._observeDataChannel(channel, this);\n    }\n  }, {\n    key: 'sendFile',\n    value: function sendFile(file) {\n      var sender = new _filetransfer2.default.Sender();\n      var dc = this.getDataChannel('filetransfer' + new Date().getTime(), {\n        protocol: INBAND_FILETRANSFER_V1\n      }); // override onopen\n\n      dc.onopen = function () {\n        dc.send(JSON.stringify({\n          size: file.size,\n          name: file.name\n        }));\n        sender.send(file, dc);\n      }; // override onclose\n\n\n      dc.onclose = function () {\n        // ('sender received transfer');\n        sender.emit('complete');\n      };\n\n      return sender;\n    }\n  }]);\n\n  return Peer;\n}(_wildemitter2.default);\n\nexports.default = Peer;","map":null,"metadata":{},"sourceType":"script"}
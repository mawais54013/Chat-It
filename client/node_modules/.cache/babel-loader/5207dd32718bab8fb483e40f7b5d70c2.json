{"ast":null,"code":"var SENDERS = require('./senders');\n\nvar parsers = require('./parsers');\n\nvar idCounter = Math.random();\n\nexports._setIdCounter = function (counter) {\n  idCounter = counter;\n};\n\nexports.toSessionJSON = function (sdp, opts) {\n  var i;\n  var creators = opts.creators || [];\n  var role = opts.role || 'initiator';\n  var direction = opts.direction || 'outgoing'; // Divide the SDP into session and media sections.\n\n  var media = sdp.split(/\\r?\\nm=/);\n\n  for (i = 1; i < media.length; i++) {\n    media[i] = 'm=' + media[i];\n\n    if (i !== media.length - 1) {\n      media[i] += '\\r\\n';\n    }\n  }\n\n  var session = media.shift() + '\\r\\n';\n  var sessionLines = parsers.lines(session);\n  var parsed = {};\n  var contents = [];\n\n  for (i = 0; i < media.length; i++) {\n    contents.push(exports.toMediaJSON(media[i], session, {\n      role: role,\n      direction: direction,\n      creator: creators[i] || 'initiator'\n    }));\n  }\n\n  parsed.contents = contents;\n  var groupLines = parsers.findLines('a=group:', sessionLines);\n\n  if (groupLines.length) {\n    parsed.groups = parsers.groups(groupLines);\n  }\n\n  return parsed;\n};\n\nexports.toMediaJSON = function (media, session, opts) {\n  var creator = opts.creator || 'initiator';\n  var role = opts.role || 'initiator';\n  var direction = opts.direction || 'outgoing';\n  var lines = parsers.lines(media);\n  var sessionLines = parsers.lines(session);\n  var mline = parsers.mline(lines[0]);\n  var content = {\n    creator: creator,\n    name: mline.media,\n    application: {\n      applicationType: 'rtp',\n      media: mline.media,\n      payloads: [],\n      encryption: [],\n      feedback: [],\n      headerExtensions: []\n    },\n    transport: {\n      transportType: 'iceUdp',\n      candidates: [],\n      fingerprints: []\n    }\n  };\n\n  if (mline.media == 'application') {\n    // FIXME: the description is most likely to be independent\n    // of the SDP and should be processed by other parts of the library\n    content.application = {\n      applicationType: 'datachannel'\n    };\n    content.transport.sctp = [];\n  }\n\n  var desc = content.application;\n  var trans = content.transport; // If we have a mid, use that for the content name instead.\n\n  var mid = parsers.findLine('a=mid:', lines);\n\n  if (mid) {\n    content.name = mid.substr(6);\n  }\n\n  if (parsers.findLine('a=sendrecv', lines, sessionLines)) {\n    content.senders = 'both';\n  } else if (parsers.findLine('a=sendonly', lines, sessionLines)) {\n    content.senders = SENDERS[role][direction].sendonly;\n  } else if (parsers.findLine('a=recvonly', lines, sessionLines)) {\n    content.senders = SENDERS[role][direction].recvonly;\n  } else if (parsers.findLine('a=inactive', lines, sessionLines)) {\n    content.senders = 'none';\n  }\n\n  if (desc.applicationType == 'rtp') {\n    var bandwidth = parsers.findLine('b=', lines);\n\n    if (bandwidth) {\n      desc.bandwidth = parsers.bandwidth(bandwidth);\n    }\n\n    var ssrc = parsers.findLine('a=ssrc:', lines);\n\n    if (ssrc) {\n      desc.ssrc = ssrc.substr(7).split(' ')[0];\n    }\n\n    var rtpmapLines = parsers.findLines('a=rtpmap:', lines);\n    rtpmapLines.forEach(function (line) {\n      var payload = parsers.rtpmap(line);\n      payload.parameters = [];\n      payload.feedback = [];\n      var fmtpLines = parsers.findLines('a=fmtp:' + payload.id, lines); // There should only be one fmtp line per payload\n\n      fmtpLines.forEach(function (line) {\n        payload.parameters = parsers.fmtp(line);\n      });\n      var fbLines = parsers.findLines('a=rtcp-fb:' + payload.id, lines);\n      fbLines.forEach(function (line) {\n        payload.feedback.push(parsers.rtcpfb(line));\n      });\n      desc.payloads.push(payload);\n    });\n    var cryptoLines = parsers.findLines('a=crypto:', lines, sessionLines);\n    cryptoLines.forEach(function (line) {\n      desc.encryption.push(parsers.crypto(line));\n    });\n\n    if (parsers.findLine('a=rtcp-mux', lines)) {\n      desc.mux = true;\n    }\n\n    if (parsers.findLine('a=rtcp-rsize', lines)) {\n      desc.rsize = true;\n    }\n\n    var fbLines = parsers.findLines('a=rtcp-fb:*', lines);\n    fbLines.forEach(function (line) {\n      desc.feedback.push(parsers.rtcpfb(line));\n    });\n    var extLines = parsers.findLines('a=extmap:', lines);\n    extLines.forEach(function (line) {\n      var ext = parsers.extmap(line);\n      ext.senders = SENDERS[role][direction][ext.senders];\n      desc.headerExtensions.push(ext);\n    });\n    var ssrcGroupLines = parsers.findLines('a=ssrc-group:', lines);\n    desc.sourceGroups = parsers.sourceGroups(ssrcGroupLines || []);\n    var ssrcLines = parsers.findLines('a=ssrc:', lines);\n    var sources = desc.sources = parsers.sources(ssrcLines || []);\n    var msidLine = parsers.findLine('a=msid:', lines);\n\n    if (msidLine) {\n      var msid = parsers.msid(msidLine);\n      ['msid', 'mslabel', 'label'].forEach(function (key) {\n        for (var i = 0; i < sources.length; i++) {\n          var found = false;\n\n          for (var j = 0; j < sources[i].parameters.length; j++) {\n            if (sources[i].parameters[j].key === key) {\n              found = true;\n            }\n          }\n\n          if (!found) {\n            sources[i].parameters.push({\n              key: key,\n              value: msid[key]\n            });\n          }\n        }\n      });\n    }\n\n    if (parsers.findLine('a=x-google-flag:conference', lines, sessionLines)) {\n      desc.googConferenceFlag = true;\n    }\n  } // transport specific attributes\n\n\n  var fingerprintLines = parsers.findLines('a=fingerprint:', lines, sessionLines);\n  var setup = parsers.findLine('a=setup:', lines, sessionLines);\n  fingerprintLines.forEach(function (line) {\n    var fp = parsers.fingerprint(line);\n\n    if (setup) {\n      fp.setup = setup.substr(8);\n    }\n\n    trans.fingerprints.push(fp);\n  });\n  var ufragLine = parsers.findLine('a=ice-ufrag:', lines, sessionLines);\n  var pwdLine = parsers.findLine('a=ice-pwd:', lines, sessionLines);\n\n  if (ufragLine && pwdLine) {\n    trans.ufrag = ufragLine.substr(12);\n    trans.pwd = pwdLine.substr(10);\n    trans.candidates = [];\n    var candidateLines = parsers.findLines('a=candidate:', lines, sessionLines);\n    candidateLines.forEach(function (line) {\n      trans.candidates.push(exports.toCandidateJSON(line));\n    });\n  }\n\n  if (desc.applicationType == 'datachannel') {\n    var sctpmapLines = parsers.findLines('a=sctpmap:', lines);\n    sctpmapLines.forEach(function (line) {\n      var sctp = parsers.sctpmap(line);\n      trans.sctp.push(sctp);\n    });\n  }\n\n  return content;\n};\n\nexports.toCandidateJSON = function (line) {\n  var candidate = parsers.candidate(line.split(/\\r?\\n/)[0]);\n  candidate.id = (idCounter++).toString(36).substr(0, 12);\n  return candidate;\n};","map":null,"metadata":{},"sourceType":"script"}
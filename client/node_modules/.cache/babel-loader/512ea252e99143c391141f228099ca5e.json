{"ast":null,"code":"var WildEmitter = require('wildemitter');\n\nvar util = require('util');\n\nfunction Sender(opts) {\n  WildEmitter.call(this);\n  var options = opts || {};\n  this.config = {\n    chunksize: 16384,\n    pacing: 0\n  }; // set our config from options\n\n  var item;\n\n  for (item in options) {\n    this.config[item] = options[item];\n  }\n\n  this.file = null;\n  this.channel = null;\n}\n\nutil.inherits(Sender, WildEmitter);\n\nSender.prototype.send = function (file, channel) {\n  var self = this;\n  this.file = file;\n  this.channel = channel;\n  var usePoll = typeof channel.bufferedAmountLowThreshold !== 'number';\n  var offset = 0;\n\n  var sliceFile = function sliceFile() {\n    var reader = new window.FileReader();\n\n    reader.onload = function () {\n      return function (e) {\n        self.channel.send(e.target.result);\n        self.emit('progress', offset, file.size, e.target.result);\n\n        if (file.size > offset + e.target.result.byteLength) {\n          if (usePoll) {\n            window.setTimeout(sliceFile, self.config.pacing);\n          } else if (channel.bufferedAmount <= channel.bufferedAmountLowThreshold) {\n            window.setTimeout(sliceFile, 0);\n          } else {// wait for bufferedAmountLow to fire\n          }\n        } else {\n          self.emit('progress', file.size, file.size, null);\n          self.emit('sentFile');\n        }\n\n        offset = offset + self.config.chunksize;\n      };\n    }(file);\n\n    var slice = file.slice(offset, offset + self.config.chunksize);\n    reader.readAsArrayBuffer(slice);\n  };\n\n  if (!usePoll) {\n    channel.bufferedAmountLowThreshold = 8 * this.config.chunksize;\n    channel.addEventListener('bufferedamountlow', sliceFile);\n  }\n\n  window.setTimeout(sliceFile, 0);\n};\n\nfunction Receiver() {\n  WildEmitter.call(this);\n  this.receiveBuffer = [];\n  this.received = 0;\n  this.metadata = {};\n  this.channel = null;\n}\n\nutil.inherits(Receiver, WildEmitter);\n\nReceiver.prototype.receive = function (metadata, channel) {\n  var self = this;\n\n  if (metadata) {\n    this.metadata = metadata;\n  }\n\n  this.channel = channel; // chrome only supports arraybuffers and those make it easier to calc the hash\n\n  channel.binaryType = 'arraybuffer';\n\n  this.channel.onmessage = function (event) {\n    var len = event.data.byteLength;\n    self.received += len;\n    self.receiveBuffer.push(event.data);\n    self.emit('progress', self.received, self.metadata.size, event.data);\n\n    if (self.received === self.metadata.size) {\n      self.emit('receivedFile', new window.Blob(self.receiveBuffer), self.metadata);\n      self.receiveBuffer = []; // discard receivebuffer\n    } else if (self.received > self.metadata.size) {\n      // FIXME\n      console.error('received more than expected, discarding...');\n      self.receiveBuffer = []; // just discard...\n    }\n  };\n};\n\nmodule.exports = {};\nmodule.exports.support = typeof window !== 'undefined' && window && window.File && window.FileReader && window.Blob;\nmodule.exports.Sender = Sender;\nmodule.exports.Receiver = Receiver;","map":null,"metadata":{},"sourceType":"script"}
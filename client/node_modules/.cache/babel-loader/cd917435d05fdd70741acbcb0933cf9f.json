{"ast":null,"code":"var SENDERS = require('./senders');\n\nexports.toSessionSDP = function (session, opts) {\n  var role = opts.role || 'initiator';\n  var direction = opts.direction || 'outgoing';\n  var sid = opts.sid || session.sid || Date.now();\n  var time = opts.time || Date.now();\n  var sdp = ['v=0', 'o=- ' + sid + ' ' + time + ' IN IP4 0.0.0.0', 's=-', 't=0 0'];\n  var contents = session.contents || [];\n  var hasSources = false;\n  contents.forEach(function (content) {\n    if (content.application.sources && content.application.sources.length) {\n      hasSources = true;\n    }\n  });\n\n  if (hasSources) {\n    sdp.push('a=msid-semantic: WMS *');\n  }\n\n  var groups = session.groups || [];\n  groups.forEach(function (group) {\n    sdp.push('a=group:' + group.semantics + ' ' + group.contents.join(' '));\n  });\n  contents.forEach(function (content) {\n    sdp.push(exports.toMediaSDP(content, opts));\n  });\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\nexports.toMediaSDP = function (content, opts) {\n  var sdp = [];\n  var role = opts.role || 'initiator';\n  var direction = opts.direction || 'outgoing';\n  var desc = content.application;\n  var transport = content.transport;\n  var payloads = desc.payloads || [];\n  var fingerprints = transport && transport.fingerprints || [];\n  var mline = [];\n\n  if (desc.applicationType == 'datachannel') {\n    mline.push('application');\n    mline.push('1');\n    mline.push('DTLS/SCTP');\n\n    if (transport.sctp) {\n      transport.sctp.forEach(function (map) {\n        mline.push(map.number);\n      });\n    }\n  } else {\n    mline.push(desc.media);\n    mline.push('1');\n\n    if (fingerprints.length > 0) {\n      mline.push('UDP/TLS/RTP/SAVPF');\n    } else if (desc.encryption && desc.encryption.length > 0) {\n      mline.push('RTP/SAVPF');\n    } else {\n      mline.push('RTP/AVPF');\n    }\n\n    payloads.forEach(function (payload) {\n      mline.push(payload.id);\n    });\n  }\n\n  sdp.push('m=' + mline.join(' '));\n  sdp.push('c=IN IP4 0.0.0.0');\n\n  if (desc.bandwidth && desc.bandwidth.type && desc.bandwidth.bandwidth) {\n    sdp.push('b=' + desc.bandwidth.type + ':' + desc.bandwidth.bandwidth);\n  }\n\n  if (desc.applicationType == 'rtp') {\n    sdp.push('a=rtcp:1 IN IP4 0.0.0.0');\n  }\n\n  if (transport) {\n    if (transport.ufrag) {\n      sdp.push('a=ice-ufrag:' + transport.ufrag);\n    }\n\n    if (transport.pwd) {\n      sdp.push('a=ice-pwd:' + transport.pwd);\n    }\n\n    var pushedSetup = false;\n    fingerprints.forEach(function (fingerprint) {\n      sdp.push('a=fingerprint:' + fingerprint.hash + ' ' + fingerprint.value);\n\n      if (fingerprint.setup && !pushedSetup) {\n        sdp.push('a=setup:' + fingerprint.setup);\n      }\n    });\n\n    if (transport.sctp) {\n      transport.sctp.forEach(function (map) {\n        sdp.push('a=sctpmap:' + map.number + ' ' + map.protocol + ' ' + map.streams);\n      });\n    }\n  }\n\n  if (desc.applicationType == 'rtp') {\n    sdp.push('a=' + (SENDERS[role][direction][content.senders] || 'sendrecv'));\n  }\n\n  sdp.push('a=mid:' + content.name);\n\n  if (desc.sources && desc.sources.length) {\n    var streams = {};\n    desc.sources.forEach(function (source) {\n      (source.parameters || []).forEach(function (param) {\n        if (param.key === 'msid') {\n          streams[param.value] = 1;\n        }\n      });\n    });\n    streams = Object.keys(streams);\n\n    if (streams.length === 1) {\n      sdp.push('a=msid:' + streams[0]);\n    }\n  }\n\n  if (desc.mux) {\n    sdp.push('a=rtcp-mux');\n  }\n\n  if (desc.rsize) {\n    sdp.push('a=rtcp-rsize');\n  }\n\n  var encryption = desc.encryption || [];\n  encryption.forEach(function (crypto) {\n    sdp.push('a=crypto:' + crypto.tag + ' ' + crypto.cipherSuite + ' ' + crypto.keyParams + (crypto.sessionParams ? ' ' + crypto.sessionParams : ''));\n  });\n\n  if (desc.googConferenceFlag) {\n    sdp.push('a=x-google-flag:conference');\n  }\n\n  payloads.forEach(function (payload) {\n    var rtpmap = 'a=rtpmap:' + payload.id + ' ' + payload.name + '/' + payload.clockrate;\n\n    if (payload.channels && payload.channels != '1') {\n      rtpmap += '/' + payload.channels;\n    }\n\n    sdp.push(rtpmap);\n\n    if (payload.parameters && payload.parameters.length) {\n      var fmtp = ['a=fmtp:' + payload.id];\n      var parameters = [];\n      payload.parameters.forEach(function (param) {\n        parameters.push((param.key ? param.key + '=' : '') + param.value);\n      });\n      fmtp.push(parameters.join(';'));\n      sdp.push(fmtp.join(' '));\n    }\n\n    if (payload.feedback) {\n      payload.feedback.forEach(function (fb) {\n        if (fb.type === 'trr-int') {\n          sdp.push('a=rtcp-fb:' + payload.id + ' trr-int ' + (fb.value ? fb.value : '0'));\n        } else {\n          sdp.push('a=rtcp-fb:' + payload.id + ' ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));\n        }\n      });\n    }\n  });\n\n  if (desc.feedback) {\n    desc.feedback.forEach(function (fb) {\n      if (fb.type === 'trr-int') {\n        sdp.push('a=rtcp-fb:* trr-int ' + (fb.value ? fb.value : '0'));\n      } else {\n        sdp.push('a=rtcp-fb:* ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));\n      }\n    });\n  }\n\n  var hdrExts = desc.headerExtensions || [];\n  hdrExts.forEach(function (hdr) {\n    sdp.push('a=extmap:' + hdr.id + (hdr.senders ? '/' + SENDERS[role][direction][hdr.senders] : '') + ' ' + hdr.uri);\n  });\n  var ssrcGroups = desc.sourceGroups || [];\n  ssrcGroups.forEach(function (ssrcGroup) {\n    sdp.push('a=ssrc-group:' + ssrcGroup.semantics + ' ' + ssrcGroup.sources.join(' '));\n  });\n  var ssrcs = desc.sources || [];\n  ssrcs.forEach(function (ssrc) {\n    for (var i = 0; i < ssrc.parameters.length; i++) {\n      var param = ssrc.parameters[i];\n      sdp.push('a=ssrc:' + (ssrc.ssrc || desc.ssrc) + ' ' + param.key + (param.value ? ':' + param.value : ''));\n    }\n  });\n  var candidates = transport.candidates || [];\n  candidates.forEach(function (candidate) {\n    sdp.push(exports.toCandidateSDP(candidate));\n  });\n  return sdp.join('\\r\\n');\n};\n\nexports.toCandidateSDP = function (candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.ip);\n  sdp.push(candidate.port);\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n\n  if (type === 'srflx' || type === 'prflx' || type === 'relay') {\n    if (candidate.relAddr && candidate.relPort) {\n      sdp.push('raddr');\n      sdp.push(candidate.relAddr);\n      sdp.push('rport');\n      sdp.push(candidate.relPort);\n    }\n  }\n\n  if (candidate.tcpType && candidate.protocol.toUpperCase() == 'TCP') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n\n  sdp.push('generation');\n  sdp.push(candidate.generation || '0'); // FIXME: apparently this is wrong per spec\n  // but then, we need this when actually putting this into\n  // SDP so it's going to stay.\n  // decision needs to be revisited when browsers dont\n  // accept this any longer\n\n  return 'a=candidate:' + sdp.join(' ');\n};","map":null,"metadata":{},"sourceType":"script"}
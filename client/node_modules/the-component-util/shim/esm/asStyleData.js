/**
 * Mark as style data
 * @function asStyleData
 * @param {string} scopeSelector - Selector which wraps data
 * @param {Object} data - Style data
 * @returns {Object} Style data
 */
'use strict';

import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _typeof from "@babel/runtime/helpers/typeof";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import argx from 'argx';

var combineSelectors = function combineSelectors() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return selectors.filter(Boolean).map(function (selector) {
    return String(selector).trim();
  }).reduce(function (combined, selector) {
    if (!combined) {
      return selector;
    }

    var JOIN_PATTERN = /^&/;

    if (JOIN_PATTERN.test(selector)) {
      return combined + selector.replace(JOIN_PATTERN, '');
    }

    return [combined, selector].join(' ');
  }, null).trim();
};

var selectorData = function selectorData(selector, data) {
  var attributes = {};
  var nested = {};

  var _arr = Object.keys(data);

  for (var _i = 0; _i < _arr.length; _i++) {
    var key = _arr[_i];

    switch (_typeof(data[key])) {
      case 'object':
        {
          nested[key] = data[key];
          break;
        }

      default:
        {
          attributes[key] = data[key];
          break;
        }
    }
  }

  return Object.assign(_defineProperty({}, selector, attributes), asStyleData(selector, nested));
};
/** @lends asStyleData */


function asStyleData(scopeSelector, data) {
  var args = argx(arguments);
  scopeSelector = args.shift('string');
  data = args.pop('object');
  return Object.keys(data).reduce(function (scoped, selector) {
    return Object.assign.apply(Object, [scoped].concat(_toConsumableArray(selector.split(',').map(function (aSelector) {
      var created = selectorData(combineSelectors(scopeSelector, aSelector), data[selector]);
      return Object.keys(created).reduce(function (result, key) {
        return Object.assign(result, _defineProperty({}, key, Object.assign({}, scoped[key] || {}, created[key])));
      }, {});
    }))));
  }, {});
}

export default asStyleData;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzU3R5bGVEYXRhLmpzIl0sIm5hbWVzIjpbImFyZ3giLCJjb21iaW5lU2VsZWN0b3JzIiwic2VsZWN0b3JzIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm1hcCIsInNlbGVjdG9yIiwiU3RyaW5nIiwidHJpbSIsInJlZHVjZSIsImNvbWJpbmVkIiwiSk9JTl9QQVRURVJOIiwidGVzdCIsInJlcGxhY2UiLCJqb2luIiwic2VsZWN0b3JEYXRhIiwiZGF0YSIsImF0dHJpYnV0ZXMiLCJuZXN0ZWQiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwiYXNzaWduIiwiYXNTdHlsZURhdGEiLCJzY29wZVNlbGVjdG9yIiwiYXJncyIsImFyZ3VtZW50cyIsInNoaWZ0IiwicG9wIiwic2NvcGVkIiwic3BsaXQiLCJhU2VsZWN0b3IiLCJjcmVhdGVkIiwicmVzdWx0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU9BOzs7OztBQUNBLE9BQU9BLElBQVAsTUFBaUIsTUFBakI7O0FBRUEsSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQjtBQUFBLG9DQUFJQyxTQUFKO0FBQUlBLElBQUFBLFNBQUo7QUFBQTs7QUFBQSxTQUN2QkEsU0FBUyxDQUNOQyxNQURILENBQ1VDLE9BRFYsRUFFR0MsR0FGSCxDQUVPLFVBQUNDLFFBQUQ7QUFBQSxXQUFjQyxNQUFNLENBQUNELFFBQUQsQ0FBTixDQUFpQkUsSUFBakIsRUFBZDtBQUFBLEdBRlAsRUFHR0MsTUFISCxDQUdVLFVBQUNDLFFBQUQsRUFBV0osUUFBWCxFQUF3QjtBQUM5QixRQUFJLENBQUNJLFFBQUwsRUFBZTtBQUNiLGFBQU9KLFFBQVA7QUFDRDs7QUFDRCxRQUFNSyxZQUFZLEdBQUcsSUFBckI7O0FBQ0EsUUFBSUEsWUFBWSxDQUFDQyxJQUFiLENBQWtCTixRQUFsQixDQUFKLEVBQWlDO0FBQy9CLGFBQU9JLFFBQVEsR0FBR0osUUFBUSxDQUFDTyxPQUFULENBQWlCRixZQUFqQixFQUErQixFQUEvQixDQUFsQjtBQUNEOztBQUNELFdBQU8sQ0FBQ0QsUUFBRCxFQUFXSixRQUFYLEVBQXFCUSxJQUFyQixDQUEwQixHQUExQixDQUFQO0FBQ0QsR0FaSCxFQVlLLElBWkwsRUFhR04sSUFiSCxFQUR1QjtBQUFBLENBQXpCOztBQWdCQSxJQUFNTyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFDVCxRQUFELEVBQVdVLElBQVgsRUFBb0I7QUFDdkMsTUFBTUMsVUFBVSxHQUFHLEVBQW5CO0FBQ0EsTUFBTUMsTUFBTSxHQUFHLEVBQWY7O0FBRnVDLGFBR3JCQyxNQUFNLENBQUNDLElBQVAsQ0FBWUosSUFBWixDQUhxQjs7QUFHdkMsMkNBQXFDO0FBQWhDLFFBQU1LLEdBQUcsV0FBVDs7QUFDSCxvQkFBZUwsSUFBSSxDQUFDSyxHQUFELENBQW5CO0FBQ0UsV0FBSyxRQUFMO0FBQWU7QUFDYkgsVUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU4sR0FBY0wsSUFBSSxDQUFDSyxHQUFELENBQWxCO0FBQ0E7QUFDRDs7QUFDRDtBQUFTO0FBQ1BKLFVBQUFBLFVBQVUsQ0FBQ0ksR0FBRCxDQUFWLEdBQWtCTCxJQUFJLENBQUNLLEdBQUQsQ0FBdEI7QUFDQTtBQUNEO0FBUkg7QUFVRDs7QUFDRCxTQUFPRixNQUFNLENBQUNHLE1BQVAscUJBRUZoQixRQUZFLEVBRVNXLFVBRlQsR0FJTE0sV0FBVyxDQUFDakIsUUFBRCxFQUFXWSxNQUFYLENBSk4sQ0FBUDtBQU1ELENBckJEO0FBdUJBOzs7QUFDQSxTQUFTSyxXQUFULENBQXFCQyxhQUFyQixFQUFvQ1IsSUFBcEMsRUFBMEM7QUFDeEMsTUFBTVMsSUFBSSxHQUFHekIsSUFBSSxDQUFDMEIsU0FBRCxDQUFqQjtBQUNBRixFQUFBQSxhQUFhLEdBQUdDLElBQUksQ0FBQ0UsS0FBTCxDQUFXLFFBQVgsQ0FBaEI7QUFDQVgsRUFBQUEsSUFBSSxHQUFHUyxJQUFJLENBQUNHLEdBQUwsQ0FBUyxRQUFULENBQVA7QUFDQSxTQUFPVCxNQUFNLENBQUNDLElBQVAsQ0FBWUosSUFBWixFQUFrQlAsTUFBbEIsQ0FBeUIsVUFBQ29CLE1BQUQsRUFBU3ZCLFFBQVQsRUFBc0I7QUFDcEQsV0FBT2EsTUFBTSxDQUFDRyxNQUFQLE9BQUFILE1BQU0sR0FDWFUsTUFEVyw0QkFFUnZCLFFBQVEsQ0FBQ3dCLEtBQVQsQ0FBZSxHQUFmLEVBQW9CekIsR0FBcEIsQ0FBd0IsVUFBQzBCLFNBQUQsRUFBZTtBQUN4QyxVQUFNQyxPQUFPLEdBQUdqQixZQUFZLENBQzFCZCxnQkFBZ0IsQ0FBQ3VCLGFBQUQsRUFBZ0JPLFNBQWhCLENBRFUsRUFFMUJmLElBQUksQ0FBQ1YsUUFBRCxDQUZzQixDQUE1QjtBQUlBLGFBQU9hLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZWSxPQUFaLEVBQXFCdkIsTUFBckIsQ0FDTCxVQUFDd0IsTUFBRCxFQUFTWixHQUFUO0FBQUEsZUFDRUYsTUFBTSxDQUFDRyxNQUFQLENBQWNXLE1BQWQsc0JBQ0daLEdBREgsRUFDU0YsTUFBTSxDQUFDRyxNQUFQLENBQWMsRUFBZCxFQUFrQk8sTUFBTSxDQUFDUixHQUFELENBQU4sSUFBZSxFQUFqQyxFQUFxQ1csT0FBTyxDQUFDWCxHQUFELENBQTVDLENBRFQsRUFERjtBQUFBLE9BREssRUFLTCxFQUxLLENBQVA7QUFPRCxLQVpFLENBRlEsR0FBYjtBQWdCRCxHQWpCTSxFQWlCSixFQWpCSSxDQUFQO0FBa0JEOztBQUVELGVBQWVFLFdBQWYiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYXJrIGFzIHN0eWxlIGRhdGFcbiAqIEBmdW5jdGlvbiBhc1N0eWxlRGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlU2VsZWN0b3IgLSBTZWxlY3RvciB3aGljaCB3cmFwcyBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFN0eWxlIGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IFN0eWxlIGRhdGFcbiAqL1xuJ3VzZSBzdHJpY3QnXG5pbXBvcnQgYXJneCBmcm9tICdhcmd4J1xuXG5jb25zdCBjb21iaW5lU2VsZWN0b3JzID0gKC4uLnNlbGVjdG9ycykgPT5cbiAgc2VsZWN0b3JzXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5tYXAoKHNlbGVjdG9yKSA9PiBTdHJpbmcoc2VsZWN0b3IpLnRyaW0oKSlcbiAgICAucmVkdWNlKChjb21iaW5lZCwgc2VsZWN0b3IpID0+IHtcbiAgICAgIGlmICghY29tYmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICB9XG4gICAgICBjb25zdCBKT0lOX1BBVFRFUk4gPSAvXiYvXG4gICAgICBpZiAoSk9JTl9QQVRURVJOLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lZCArIHNlbGVjdG9yLnJlcGxhY2UoSk9JTl9QQVRURVJOLCAnJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBbY29tYmluZWQsIHNlbGVjdG9yXS5qb2luKCcgJylcbiAgICB9LCBudWxsKVxuICAgIC50cmltKClcblxuY29uc3Qgc2VsZWN0b3JEYXRhID0gKHNlbGVjdG9yLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fVxuICBjb25zdCBuZXN0ZWQgPSB7fVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkYXRhKSkge1xuICAgIHN3aXRjaCAodHlwZW9mIGRhdGFba2V5XSkge1xuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICBuZXN0ZWRba2V5XSA9IGRhdGFba2V5XVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBkYXRhW2tleV1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAge1xuICAgICAgW3NlbGVjdG9yXTogYXR0cmlidXRlcyxcbiAgICB9LFxuICAgIGFzU3R5bGVEYXRhKHNlbGVjdG9yLCBuZXN0ZWQpLFxuICApXG59XG5cbi8qKiBAbGVuZHMgYXNTdHlsZURhdGEgKi9cbmZ1bmN0aW9uIGFzU3R5bGVEYXRhKHNjb3BlU2VsZWN0b3IsIGRhdGEpIHtcbiAgY29uc3QgYXJncyA9IGFyZ3goYXJndW1lbnRzKVxuICBzY29wZVNlbGVjdG9yID0gYXJncy5zaGlmdCgnc3RyaW5nJylcbiAgZGF0YSA9IGFyZ3MucG9wKCdvYmplY3QnKVxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKChzY29wZWQsIHNlbGVjdG9yKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICBzY29wZWQsXG4gICAgICAuLi5zZWxlY3Rvci5zcGxpdCgnLCcpLm1hcCgoYVNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBzZWxlY3RvckRhdGEoXG4gICAgICAgICAgY29tYmluZVNlbGVjdG9ycyhzY29wZVNlbGVjdG9yLCBhU2VsZWN0b3IpLFxuICAgICAgICAgIGRhdGFbc2VsZWN0b3JdLFxuICAgICAgICApXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjcmVhdGVkKS5yZWR1Y2UoXG4gICAgICAgICAgKHJlc3VsdCwga2V5KSA9PlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtcbiAgICAgICAgICAgICAgW2tleV06IE9iamVjdC5hc3NpZ24oe30sIHNjb3BlZFtrZXldIHx8IHt9LCBjcmVhdGVkW2tleV0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAge30sXG4gICAgICAgIClcbiAgICAgIH0pLFxuICAgIClcbiAgfSwge30pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzU3R5bGVEYXRhXG4iXX0=